#summary RTMでの拡張型・独自型による通信サンプル

== 概要 ==

通信サンプルに拡張型や独自型を用いたRTコンポーネントプログラムの書き方について紹介する．


== 準備 ==

サンプルのチェックアウト

{{{
 $ svn checkout http://rtm-ros-robotics.googlecode.com/svn/trunk/agentsystem_rtm_tutorials
}}}

== 拡張型での通信 ==

OpenRTM-aistでは，データポート間のデータの型として，TimedShort, TimedLong, TimedFloat, TimedDoubleなどの単一の値を表す型とTimedShortSeq, TimedLongSeq, TimedFloatSeq, TimedDoubleSeqなど，それらのシーケンス型が基本型として定義されている．

これらは，/usr/include/rtm/idl/BasicDataType.idl（或いは，/usr/local/include/rtm/idl/BasicDataType.idl）に定義されており，コンポーネントの中で自由に利用出来る．

この基本型に加えて，拡張型と呼ばれるものが存在する．それらは，
/usr/include/rtm/idl/ExtendedDataTypes.idlおよび/usr/include/rtm/idl/InterfaceDataTypes.idlとして定義されており，自由に使うことができる．

=== C++での利用法 ===

ヘッダファイルに
{{{
#include <rtm/idl/InterfaceDataTypesSkel.h>
}}}

を記述すれば，後は他の基本型と同様に利用出来る．
拡張型には，例えば，下記のようなものが定義されており，

{{{
    struct Velocity2D
    {
        /// Velocity along the x axis in metres per second.                                                                                                                      
        double vx;
        /// Velocity along the y axis in metres per second.                                                                                                                      
        double vy;
        /// Yaw velocity in radians per second.                                                                                                                                  
        double va;
    };

   struct TimedVelocity2D
    {
        Time tm;
        Velocity2D data;
    };
}}}

これを用いたインポート/アウトポートの定義は，
{{{
  TimedVelocity2D m_out;
  OutPort<TimedVelocity2D> m_outOut;
}}}

のように他の型と同様に行うことができる．

=== Pythonでの利用法 ===

Pythonの場合，更に簡便であり，基本型と同様に'import RTC'さえしてあれば，利用できる．

=== サンプル ===

agentsystem_rtm_tutorials/ExtendedIdl_sample/以下のTestVelocity2DSendがcppのサンプル，TestVelocity2DRecvPyがPython側のサンプルになっている．ターミナルで，それぞれ起動する．

すなわち，片側で，
{{{
$ cd TestVelocity2DSend
$ make
$ ./TestVelocity2DSendComp
}}}
とし，もう片側で，
{{{
$ python ./TestVelocity2DRecv.py
}}}
とする．

あとは，RTSystemEditorで接続し，アクティベートすると，Recv側で値が表示されることが確認できる．

== 独自型での通信 ==

一方，ユーザが自由に定義した型で通信を行うことも可能である．自分で用意したidlを用いて通信することができる．

構造体など自由に定義して良いが，下記の2点に気をつける必要がある．
 * #include <BasicDataType.idl> を必ず含める
 * RTC::Time tmを含むTimedxxxというデータ型を作る

C++の場合，RTCBuilderで生成される雛形を修正するのが楽で良い．具体的には，Makefile中のSKEL_OBJにオブジェクトファイルを指定する．

idltest.idlを読み込ませる場合，

　　SKEL_OBJ = idltestSkel.o

のように修正前は空だった変数にidltestSkel.oをセットすると，それがOBJSにセットされ，makeのターゲットである実行ファイル及び共有ライブラリにそのままリンクされる．

ただし，idltest.idlからidltestSkel.cppとidltestSkel.hを生成する必要があるので，そのための記述を加える．

idltestSkel.cpp : idltest.idl
        $(IDLC) $(IDLFLAGS) $<
        $(WRAPPER) $(WRAPPER_FLAGS) --idl-file=$<

idltestSkel.o: idltestSkel.cpp
        $(CXX) $(CXXFLAGS) -c -o $@ $<

としておけば，最初のIDLC（実体はomniidl)を呼ぶところで idltestSkel.cpp, idltestSkel.h, idltestStub.cpp, idltestStub.hが生成され，オブジェクトファイルを作ることができるようになる．

勿論，同じ通信型を使い回す場合には，共有ライブラリを作ってやり，それを各々のコンポーネント実行ファイル等にリンクするのでも良い．

一方，Pythonの場合にも，omniidlを使ってPython用のコードを生成して利用するのは同じである．ただし，Python用のコードを生成するには，

{{{
$ omniidl -bpython -I/usr/include/rtm/idl  ./xxx.idl 
}}}
としなければいけないので注意すること．-Iをしているのは，独自idl定義の中にBasicDataType.idlをincludeしているので，それがある場所を-Iで指定することが必要があるため．

例えば，idltest.idlを上記の方法でコンパイルするとidltest_idl.pyとIdltest/, Idltest__POA/というフォルダが生成される．ここで生成された二つのフォルダは中に__init__.pyを含むフォルダなので，各々importすることができる．データ通信のみの場合は，import Idltestのみ行えば良い．サービスポートも利用する場合にはimport Idltest__POAも必要になる．

上記importさえすませば，後は，oninitialize()にて
{{{
idmsg = Idltest.Idmsg(0, "None")                                                                                 
self.RecvMsg = Idltest.TimedIdmsg(RTC.Time(0,0), idmsg)
}}}
のように参照して使うことができるようになる．ただし，Pythonの場合，きちんと対応したクラスのインスタンスを作って初期値を渡してやる必要がある．どういう初期値を与えるかは，idltest_idl.pyの中の対応する各クラス定義を参照する．

=== サンプル ===

agentsystem_rtm_tutorials/UniqueIdlTest/以下のTestSendがC++の送信側サンプル，TestRecvがC++の受信側サンプル，TestRecvPyがPython受信サンプルになっている．

C++サンプルは各々のフォルダでmakeした後，ターミナルで，それぞれ起動し，RTSystemEditorで接続，アクティベートすることで独自型のメッセージの送受信がうまくいっている様子が確認できる．一方，Python版もmakeする．これは，中で上記のomniidlを呼び出している．受信側をPython版に変えても同じ結果が出るはずである．