#summary ROSの基本概念

<wiki:toc max_depth="2" />

= 概要 =
すでに[ROS_Install ROSのインストール]は終わっていることを前提とさせていただきます。
ここでは、まだ、ROSに触れたことがないひとが、いろいろと新しいであろうROSの概念をかなり簡略化して説明できたらと思っております。概念というとかなり大げさですが、軽い用語説明みたいなものになります。

基本的に[http://www.ros.org/wiki/ROS/Tutorials ROSのTutorialsページ]を見に行っていただければ問題ないですが、軽く見ていただけると少し理解がはやまるかもしれません。

= 解説=
== 準備 ==
そこまで、大変ではないと思いますが、途中で準備に失敗することがありましたら、とりあえず、以下の実行はしないで「準備」は飛ばし次の「node/topicについて」から読み始めてもかまいません。

ここでは、ターミナルを全部で４つ開きます。まず一つ目で
{{{
roscore
}}}

２つ目で
{{{
rosrun roscpp_tutorials talker
}}}

この時点で今実行したターミナルにどんどん文字が流れているのが見えると思います。

３つ目で
{{{
rosrun roscpp_tutorials listener
}}}

と行うと、２つ目で流れているターミナルと同時に見ていただきたいのですが、おそらくほぼ同時のタイミングで同じ文字が出ているのが確認できると思います。

上のプログラムの実行で、２つ目のターミナルのtalkerがHello・・・というメッセージを送っており、listenerのほうでそれを受け取る形になってます。

最後のターミナルで
{{{
rxgraph
}}}
と打って準備は終了です。以下ではそれらを見たまま読んでいってください。


== node/topicについて==
 rosではさまざまなプログラムが立ち上がり、お互いに違う言語同士でも情報を渡しあえるような工夫がされています。この際に、簡単に言ってしまえば、それぞれのプログラムのことをnodeと呼んでいます。つまり、さまざまなところで、腕を動かすプログラム、画像を取ってくるプログラム、画像を加工するプログラムのようにばらばらに動いているそのプログラムそれぞれのことをひとつのnodeというように捉えます。
[http://rtm-ros-robotics.googlecode.com/svn/wiki/talkerListenerChart.png]

===node===
上の図のまるで囲まれているところをごらんください。それぞれがノードになっており、
上では大まかに以下のプログラム(node)が動いています。
||/talker||"Hello"というメッセージを出し続けるプログラム||
||/listener||"Hello"というメッセージを受け続けるプログラム||
||/rosout||さまざまなプログラムからのログを処理するプログラム||


のようになっています。

これらはたとえ違う言語で書かれていても同じことをするプログラムであれば、まったく同様な表示のされ方をされます。c++からのHelloというのもpythonで受け取ることなどもできます。
node名が違えば、同じプログラムでも複数起動することが可能です。

===topic===
そして次に注目をしていただきたいものが、node同士を結んでいる矢印です。矢印で書いてあるので通り抜けるイメージを持つかもしれませんが、どちらかというと、chatterというtopicにtalkerが渡して、chatterからlistenerに情報を渡すバケツリレーを想像するとわかりやすいかもしれません。それぞれの矢印には、名前が書いてありますが、ここには２種類あります。
||/chatter||talkerからの情報が流れてきていて書き込まれているところ||
||/rosout||プログラムからのログが流れてきて書き込まれているところ||


のような役割をしています。

ここで、さきほどのnodeの/rosoutとtopicの/rosoutがかぶっていますが、問題ありません。nodeのrosoutが２つあったら一つは止められてしまいます。

これらは、node同士がやりとりするためのmsg(メッセージ)を用いた手段のひとつです。例えていうならば、topicは掲示板のようなもので、この例ではtalkerが書き込み、これらに情報が書き込まれるたびに受け取り手のlistenerに情報が来たことが伝わり、listener側のプログラムで定義されるコールバック関数がよばれます。また、受け取り手が複数いてもよく、以下のような状況にすることも可能です。
[http://rtm-ros-robotics.googlecode.com/svn/wiki/talkerListenerChart2.png]

受け取る側もどのnodeからデータを取りたいかをtopic名で決めなくてはならないため、もし、受取側が指定したtopic名が存在しなければ何の情報も流れてきません。


実感がわかないかもしれないので念のためもう一例軽くあげておきますと、例えば
cameraImageMakerというnodeAが、/camera/image_rectというtopicにカメラから得た画像データを出せるときはいつもそこに流し込んでいるとします。ここで、ほかのnodeで、/camera/image_rectという名前のtopicからカメラの画像からエッジ抽出をしたいnodeB1と、/openni/rgb/image_rectという名前のtopicからカメラ画像から肌色検出したいというnodeB2が後からできたとします。

すると、rosのmasterによって、nodeB1のtopicは存在するので、常にnodeAからくるカメラ画像はnodeB1に流れ、一方、/openni/rgb/image_rectというtopicは存在しませんので、nodeB2への画像はこないままです。

== msgについて==
msg（メッセージ）はtopicを用いてnode間で情報を届けるときに渡される情報のことです。それぞれのtopicを準備するときに、そのtopicの書き込むmsg(メッセージ)の形(type)を決めなくてはなりません。

たとえば、上の例の場合topicには以下のような情報がどんどん書きこまれています。
{{{
//例です。
data: hello world 180374
---
data: hello world 180375
---
data: hello world 180376
---
data: hello world 180377
---
data: hello world 180378
---
data: hello world 180379
・・・
}}}
と書いてあります。


一方、メッセージの方の定義するファイルここではstd_msgs/String(形式の名前)の中では
{{{
string data
}}}
となっており、上のtopicに書かれているデータと対応していることがわかると思います。この場合data = "hello world 180379"の文字列のようにしてdataと言う変数に値が入るような形で情報が渡されてきます。

topicの情報を受け取る側も、受け取る準備をするときに、何の形式（type）のメッセージを受け取るか指定する必要があります。もちろん今回の場合なら同様にstd_msgs/Stringになります。

ここで、メッセージをtopicに送り出すことをpublish(パブリッシュ)、メッセージをtopicから受け取ることをsubscribe(サブスクライブ)と言うので押さえておいてください。

== srvについて==
nodeの間では、もう一つお互いに情報を渡しあう、連絡をとりあう方法があります。それをService（サービス）というように呼びます。msgとsrvは簡単には以下のような違いがあります。
 * msg
  * 情報を出すnodeは何も意識せずにtopicに情報を出し続ける。
  * 情報を受け取る側は情報が来るたびにコールバックが呼ばれる。
  * 多対多で情報の受け渡しができる。
 * srv
  * あるnode(clientと呼びます)が別のnode(serverと呼びます)に対して引数とともに関数を呼び出す。
  * 必要なときに必要な側が呼ぶことになるので、重い画像データはほしいときにserviceを用いて行うと効率がよい。
  * 1対1での連絡をしあうことになる。
  * 渡すときの形式と、もらうときの形式を別に書くことができる。
  * clientはserverから返事が来るまで、処理が動かない

srvの情報はたとえば以下のように情報が定義されていたりします。
{{{
//requestリクエストするほうの渡す引数の形式
int64 a
int64 b
---
//responseレスポンスを返すほうの形式
int64 sum
}}}

この例では、clientが好きなタイミングで、requestで足しほしい２つをServiceを用いてserverに送って、serverで足し算をした後、responseでclientに情報を渡しているプログラムです。先ほども述べたように、clientは結果が返ってくるまで何も処理をしません。



以上で、すごく簡単になってしまいましたが、rosで出てくる主な概念の説明は終わりです。あとは、launchファイルの文法が目新しいと思いますので、ROSのtutorials一通りこなしたあとに、参照していただければと思います。