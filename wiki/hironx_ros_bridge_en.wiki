#summary One-sentence summary of this page.
#labels Phase-Support
<g:plusone size="medium"></g:plusone>

This page is English translation of [https://code.google.com/p/rtm-ros-robotics/wiki/hironx_ros_bridge this page in Japanese]. In case this page (the one you're on) looks outdated, please consult the original Japanese page or ask in [https://groups.google.com/forum/#!forum/rtm-ros-robotics the mailing list]; these 2 pages are NOT guaranteed to be synchronized.

<wiki:toc />

= Motivation =
[http://wiki.ros.org/rtmros_hironx?distro=groovy hironx] (ROS-RTM based controller software suite for [http://nextage.kawada.jp/en/hiro/ Hiro]) is now [http://www.ros.org/wiki/catkin/migrating_from_rosbuild#Overview catkinized] but still compatible with ROS' old building style called rosbuild (or its command line interface `rosmake`). Let's call it `hybrid` package. This page discusses installation of hybrid version both using rosbuild and catkin. Also and the most recommended, binary of the whole software of hiro is now available for Ubuntu.

Because installation from source may not go as smooth as it should be, you're advised to use `.deb` binary version that's built using `catkin` if you're on Ubuntu unless you use ROS fuerte (where catkin is not fully functional) or have certain reasons to build from source.

= Pre-requisite =
- It's assumed that you finished:
 * download ROS by following its wiki. http://ros.org/wiki/groovy/Installation/Ubuntu
 * [http://wiki.ros.org/ROS/Tutorials ROS fundamental tutorials]. Focus on the build tool you would use (`catkin` or `rosbuild`)

- When you face troubles,
 * [https://code.google.com/p/rtm-ros-robotics/wiki/hironx_ros_bridge_en#Troubleshoot refer to the pitfalls put together as a section at the bottom of this page]. If you see any issue, please consider taking a look at the section, or you can simply text search through this page using your browser's feature.
 * More generally, [http://google.com/ Google] is always there as your best friend.

= Install =
== Install via debian binary (RECOMMENDED) ==
Available only in `ROS Groovy` and later.
*NOTE*: As of 9/19/2013 Hydro version is not yet ready.

=== Adjust to preliminary .deb repository ROS ===
*NOTE* (9/20/2013): This section will become unnecessary in the near future.

The process of creating binary files in `ROS` take awhile since the developers submitted their code due to number of reasons regarding software reliability. If you're in hurry, however, for whatever reasons to obtain newer versions binary, there's a way to do as follows. 

 1. Open `/etc/apt/sources.list.d/ros-latest.list`. If it doesn't exist, create one.

 2. Comment out any entries taht contain `packages.ros.org`

 3. Add these lines:
{{{
# Shadow-fixed
deb http://packages.ros.org/ros-shadow-fixed/ubuntu precise main
deb-src http://packages.ros.org/ros-shadow-fixed/ubuntu precise main
}}}

 4. Run on terminal:
{{{
$ sudo apt-get update 
$ sudo apt-get dist-upgrade
}}}

This way, binaries that are already built but have not yet been officially released by ROS team can be installed. This does not necessarilly mean that those binaries are unstable; instead, it's based on the release cycle of ROS binaries (cf. [https://github.com/ros/rosdistro/issues/606 this discussion]).

*WARNING* because of the reason mentioned above, you should do this only for development purpose and *never ever* use this method on production systems.

=== Download and install binary by a single command ===
{{{
$ apt-get install ros-%YOUR_ROS_DISTRO%-rtmros-hironx ros-%YOUR_ROS_DISTRO%-rtshell-core

$ apt-get install ros-groovy-rtmros-hironx ros-groovy-rtshell-core
     (for example)
}}}

This will install all missing dependency including:
 * ros-groovy-openrtm-aist-core
 * ros-groovy-openhrp3
 * ros-groovy-hrpsys
 * ros-groovy-rtmros-common

Additionally you may have to install:

{{{
$ apt-get install ros-%YOUR_ROS_DISTRO%-moveit-ros-visualization
}}}


=== Update binaries ===
When you know that newer binary version is available,

{{{
$ sudo apt-get update 
$ sudo apt-get dist-upgrade
}}}

This will install newer version of what's already installed if available. 

== Install from source ==
NOTE: Once again, you're encouraged to use binary for many reasons unless you have specific reasons to build from source.

Create directory.

{{{
$ mkdir -p catkin_ws/src; cd catkin_ws/src
}}}

You may notice that we are naming a source folder as `catkin`. Besides that this is just a naming build tool does not care, `catkin` as a convention prefers its work folder as to be called something like "catkin", "workspace". If you're building with `rosbuild` in the following subsection, this folder name is still valid (but if you feel confusing feel free to change it).

The following subsections are separated for you per build tool you use. All ROS `Fuerte` users use `rosbuild`. The `Groovy` users who never used or even heard of a word `catkin` but still have some experience in ROS, you're likely a `rosbuild` user.

=== Source build by rosbuild (rosmake) ===
If you're on ROS `Groovy` or later where its new build system `catkin` is ready and stable, skip this subsection and goto `catkin`. However, `rosbuild` still sticks around without any problem.

First setup a workspace at `src` dir.
{{{
$ rosws init
}}}
Then open with your favorite editor `.rosinstall` file that should be created by the previous command. Then add ROS environment info (as [http://docs.ros.org/independent/api/rosinstall/html/rosws_tutorial.html#adding-ros-to-workspace noted in tutorial]):

{{{
- setup-file:
    local-name: /opt/ros/%YOUR_ROS_DISTRO%/setup.*sh
}}}

    For example if you're using Groovy on `bash`,
    {{{
    - setup-file:
        local-name: /opt/ros/groovy/setup.bash
    }}}

Then update the same file, obtain the source, and setup ROS environment by following:
{{{
$ rosws merge https://rtm-ros-robotics.googlecode.com/svn/trunk/rtm-ros-robotics.rosinstall
$ rosws update
$ source setup.*sh     (choose either script file that suits your needs)
}}}

    After `rosws merge`, the `rosinstall` file should look something like:
    {{{
    # THIS IS AN AUTOGENERATED FILE, LAST GENERATED USING wstool ON 2013-08-31
    - setup-file:
        local-name: /opt/ros/groovy/setup.sh
    - svn: {local-name: rtm-ros-robotics/openrtm_common, uri: 'https://rtm-ros-robotics.googlecode.com/svn/trunk/openrtm_common'}
    - svn: {local-name: rtm-ros-robotics/rtmros_common, uri: 'https://rtm-ros-robotics.googlecode.com/svn/trunk/rtmros_common'}
    - svn: {local-name: rtm-ros-robotics/rtmros_hironx, uri: 'https://rtm-ros-robotics.googlecode.com/svn/trunk/rtmros_hironx'}
    - svn: {local-name: rtm-ros-robotics/openrtm_apps, uri: 'https://rtm-ros-robotics.googlecode.com/svn/trunk/openrtm_apps'}
    }}}

Now you're ready to build by:
{{{
$ rosmake hironx_ros_bridge
}}}

Here, if you see rosmake stops with error at a particular package, 
{{{
$ cd %PKG_THAT_CAUSED_ERR%
$ make
}}}

If this passed then do the same `rosmake` again. 
Packages that are reported to cause error: hrpsys_ros_bridge, hironx_moveit_config

To vefify that it runs, go on to next section to run simulator.

=== Source build by Catkin ===
*NOTE*: Many times again, you're encouraged to use binary for many reasons unless you have specific reasons to build from source.

First obtain source. In `src` folder,
{{{
$ wstool init
$ wstool merge https://rtm-ros-robotics.googlecode.com/svn/trunk/rtm-ros-robotics.rosinstall
$ wstool update
$ catkin_init_workspace
}}}

# [http://www.ros.org/wiki/wstool wstools] takes over rosws for catkin workspace. Since we're not building in catkin workspace in this rosbuild section, you can keep using `rosws` if you feel like. The result shouldn't be different.

The above commands downloads necessary codes.

Before you become able to build your `catkin workspace`, you need to make sure that you have all the required dependencies. We use [http://wiki.ros.org/rosdep rosdep] for this:
{{{
$ cd ..     (moving back to catkin_ws)
$ rosdep install --from-paths src --ignore-src --rosdistro groovy -y -r
}}}
This will look at all of the packages in the `src` directory and find all of the dependencies they have. Then it will recursively install the dependencies, without stopping at any errors that may or may not occur.

*NOTE*: it's known that the above command using `rosdep` doesn't install all dependency for wet packages (ie. packages that are built using `catkin`) due to the spec of current `rosdep` (Oct 2013, [http://answers.ros.org/question/99756/rosdep-install-ignores-a-package-thats-actually-missing Related thread]). gm130s is writing a patch for it.

Now you're ready to start building:
{{{
$ catkin_make
$ source devel/setup.bash   (or any shell script you would prefer under `/devel`)
}}}

    NOTE-1; building by `catkin` might fail sometimes and workaround often works is just re-run `catkin_make`.

    NOTE-2; If you updated source (by either downloading from devel repository or modifying by yourself), you should clean your source directories in your workspace by:

    {{{
$ cd %HOMEDIR_YOUR_CATKIN_WORKSPACE%
$ rm -fR build devel
    }}}

In addition, only if you're building both `rosbuild` and `catkin` for whatever purpose, it's necessary for `rtm-ros-robotics` that enables "hybrid" build of both `rosbuild` and `catkin` and thus uses source folders for building work (cleaning your source folder is unusual usage in `catkin` workspace in general).
{{{
$ catkin_make clean
}}}

=== Install ROS and hironx from source (both build system) ===
If you dare to, or have a reason to install not just hironx but ROS itself too from source, you can still take advantage of `.rosinstall` file to manage all the source repositories you need to obtain sources from. Use [http://wiki.ros.org/rosinstall_generator rosinstall_generator]. 

{{{
$ rosinstall_generator hironx_ros_bridge --rosdistro groovy --deps --wet-only > groovy-hironx-wet.rosinstall
}}}

Simple this command creates a `.rosintall` file that has a long list of all source repos.

= Usage =
Common for simulation and for real robot
Config the envinronment for rtm things.
{{{
$ source `rospack find openrtm_tools`/scripts/rtshell-setup.sh
}}}

    The above command includes setting `PYTHONPATH` for [http://wiki.ros.org/rtshell rtshell], creating aliases to more easily run `rtm` tools:

    {{{
    $ alias rtmlaunch='`rospack find hrpsys_ros_bridge`/scripts/rtmlaunch'
    $ alias rtmtest='`rospack find hrpsys_ros_bridge`/scripts/rtmtest'
    }}}

== Working in a simulator environment ==
Then, launch a simulator.
{{{
$ rtmlaunch hironx_ros_bridge hironx_ros_bridge_simulation.launch 
}}}

    This launch file does mainly two things; load a virtual robot on the simulator by:
    {{{
    $ rtmlaunch hrionx_ros_bridge hironx_startup.launch
    }}}
    
    And start processes that work as a bridge between ROS and hrpsys.
    {{{
    $ roslaunch hrionx_ros_bridge hironx_ros_bridge.launch
    }}}

If you see the following or similar on command prompt, your simulator is good:

    {{{
    [ INFO] [1375160303.399785831, 483.554999999]: [HrpsysSeqStateROSBridge0] @onExecutece 0 is working at 201[Hz]
    [ INFO] [1375160304.408500642, 484.544999999]: [HrpsysSeqStateROSBridge0] @onExecutece 0 is working at 198[Hz]
    }}}

    And a robot on `hrpsys` viewer like this:
    http://wiki.ros.org/hrpsys?action=AttachFile&do=get&target=snap_tutorial_hrpsysViewer.png

Then setting for `CORBA`.
{{{
$ export ORBInitRef="NameService=corbaloc:iiop:localhost:15005/NameService"
}}}

You can check robot model on RViz visualizer:
{{{
$ rosrun rviz rviz -d `rospack find hironx_ros_bridge`/models/kawada-hironx.rviz
}}}

== Working with a real robot ==
Since `hrpsys` should be already running if the real robot is on, you only have to launch [http://wiki.ros.org/hrpsys_ros_bridge hrpsys_ros_bridge] on your computer. Replace `%HOSTNAME%` with an appropriate value in your environment; eg. `hiro001`;
{{{
$ roslaunch hironx_ros_bridge hironx_ros_bridge.launch nameserver:=%HOSTNAME%
}}}

Then do something like this (adjust to your environment especially the location of wrl file, port number, robot's hostname):
{{{
$ rosrun hironx_ros_bridge hironx.py RobotHardware0  /opt/jsk/etc/HIRONX/model/main_15dof.wrl -- -ORBInitRef NameService=corbaloc:iiop:hiro014:15005/NameService
}}}

== Initialization ==
Now from here both simulation and robot users do the same.

Initialization:
{{{
$ rosrun hironx_ros_bridge hironx.py
}}}

    What this command does includes:

    * (Followings are general to hrpsys) Find RTCManager and RobotHardware.
    * Create, connect to, and activate the RT components initially necessary for `hrpsys` controller.
    * Run logger.
    * (Specific to Hiro) Assign link groups.

== Monitoring ROS state using rqt ==
ROS' new GUI toolset introduced from `Groovy` called [http://ros.org/wiki/rqt rqt] help you to ease the pain to visualize data during development. Here is the suggestion of some tools particularly helpful for `Hiro` (out of [http://www.ros.org/wiki/rqt/Plugins 30+ rqt tools]:)

Run:
{{{
$ rqt
}}}

Then click on "Plugins" and choose:
 * `ROS Graph` ([http://wiki.ros.org/rqt_graph rqt_graph])
 * `Robot Monitor` ([http://wiki.ros.org/rqt_robot_monitor rqt_robot_monitor]. This name is expected to be renamed as `Diagnostic Viewer`)
 * `Topic Introspection` ([http://wiki.ros.org/rqt_topic rqt_topic])

You will see a window that looks like this:
http://wiki.ros.org/hironx_ros_bridge?action=AttachFile&do=get&target=snap_rqt_graph_monitor_topic_vertical.png

    (Robot Monitor only show `stale` status since this image was taken with simulator where no `diagnosis` is available)

== Interact with the robot via moveIt ==
You might want to install first `OMPL` planner if you already haven't done so.
{{{
$ apt-get install ros-%YOUR_ROS_DISTRO%-moveit-planners-ompl
}}}

You can use `MoveIt!` `RViz` plugin for interactive manipulation on GUI.
{{{
$ roslaunch hironx_moveit_config moveit_planning_execution.launch
}}}

http://wiki.ros.org/hironx_moveit_config?action=AttachFile&do=get&target=snap_tutorial_hironx_moveitRvizPlugin.png

    This spawns a new `ROS Node` called "`move_group`" that provides an interface specific to `hironx` and `MoveIt!` motion planner. 

    rqt_graph now shows it too:
    http://wiki.ros.org/hironx_ros_bridge?action=AttachFile&do=get&target=snap_rqt_moveit_hironx.png

Refer to [http://moveit.ros.org/wiki/PR2/Rviz_Plugin/Quick_Start plugin usage page] (the page uses `PR2` humanoid but you can get the essense). 

Note: [http://wiki.ros.org/interactive_markers Interactive Markers] have not really been implemented with `Hiro`. Patch from YOU is welcomed :).

== Programming example ==

You have options in how you write robot's manipulation task:

 * [http://www.ros.org/wiki/hrpsys hrpsys] in `python`
 * [http://moveit.ros.org/ MoveIt!] in `python`
 * [http://moveit.ros.org/ MoveIt!] in `C++`

The first two are covered in the following subsections. Note that you can mix all of them to accomplish the task you want. And while using `python`, you can implement codes of `hrpsys` and `MoveIt!` within a single `python` module if you like.

=== Operate robot via hrpsys in Python ===
`Hiro`'s control interface is defined in [http://code.google.com/p/rtm-ros-robotics/source/browse/trunk/rtmros_hironx/hironx_ros_bridge/scripts/hironx.py hironx_ros_bridge/scripts/hironx.py], which has been already introduced earlier a few times. Here's an example `python` script of how to use it. Here we use `ipython` because of its light-weight but sufficient functionality.

This is the same initialization step as discussed earlier; you're now just doing it on `ipython` shell.
{{{
rospaghetti@italy:$ ipython -i `rospack find hironx_ros_bridge`/scripts/hironx.py
[hrpsys.py]  waiting ModelLoader
[hrpsys.py]  start hrpsys
[hrpsys.py]  finding RTCManager and RobotHardware
:
[hrpsys.py]  initialized successfully
}}}

This instantiate `HIRONX` class as a variable `hiro`. Now see what's available inside of `hiro` by:
{{{
In : hiro.
}}}

You can tab-complete to know what's available:
{{{
hiro.Groups                            hiro.getCurrentRPY                     hiro.rh_svc
hiro.HandClose                         hiro.getCurrentRotation                hiro.saveLog
hiro.HandGroups                        hiro.getJointAngles                    hiro.sc
hiro.HandOpen                          hiro.getRTCInstanceList                hiro.sc_svc
hiro.InitialPose                       hiro.getRTCList                        hiro.sensors
hiro.OffPose                           hiro.getReferencePose                  hiro.seq
hiro.RtcList                           hiro.getReferencePosition              hiro.seq_svc
hiro.abc                               hiro.getReferenceRPY                   hiro.servoOff
hiro.activateComps                     hiro.getReferenceRotation              hiro.servoOn
hiro.afs                               hiro.getSensors                        hiro.setHandEffort
hiro.checkEncoders                     hiro.goActual                          hiro.setHandJointAngles
hiro.clearLog                          hiro.goInitial                         hiro.setHandWidth
hiro.co                                hiro.goOffPose                         hiro.setJointAngle
hiro.co_svc                            hiro.hand_width2angles                 hiro.setJointAngles
hiro.configurator_name                 hiro.hgc                               hiro.setJointAnglesOfGroup
hiro.connectComps                      hiro.ic                                hiro.setSelfGroups
hiro.connectLoggerPort                 hiro.init                              hiro.setTargetPose
hiro.createComp                        hiro.isCalibDone                       hiro.setupLogger
hiro.createComps                       hiro.isServoOn                         hiro.sh
hiro.el                                hiro.kf                                hiro.sh_svc
hiro.el_svc                            hiro.lengthDigitalInput                hiro.simulation_mode
hiro.ep_svc                            hiro.lengthDigitalOutput               hiro.st
hiro.findModelLoader                   hiro.liftRobotUp                       hiro.stOff
hiro.fk                                hiro.loadPattern                       hiro.tf
hiro.fk_svc                            hiro.log                               hiro.vs
hiro.flat2Groups                       hiro.log_svc                           hiro.waitForModelLoader
hiro.getActualState                    hiro.moveHand                          hiro.waitForRTCManagerAndRoboHardware
hiro.getBodyInfo                       hiro.ms                                hiro.waitInterpolation
hiro.getCurrentPose                    hiro.readDigitalInput                  hiro.waitInterpolationOfGroup
hiro.getCurrentPosition                hiro.rh                                hiro.writeDigitalOutput
}}}

See the list of link groups and its member `link`s:
{{{
In : hiro.Groups
Out: 
[['torso', ['CHEST_JOINT0']],
 ['head', ['HEAD_JOINT0', 'HEAD_JOINT1']],
 ['rarm',
  ['RARM_JOINT0',
   'RARM_JOINT1',
   'RARM_JOINT2',
   'RARM_JOINT3',
   'RARM_JOINT4',
   'RARM_JOINT5']],
 ['larm',
  ['LARM_JOINT0',
   'LARM_JOINT1',
   'LARM_JOINT2',
   'LARM_JOINT3',
   'LARM_JOINT4',
   'LARM_JOINT5']]]
}}}

An advantage of `ipython` as a script interpreter is that you can get api info. Suppose you're looking for how to get the current pose but you have no idea of command, first just guess and tab-complete:
{{{
In : hiro.getCurrent
hiro.getCurrentPose      hiro.getCurrentPosition  hiro.getCurrentRPY       hiro.getCurrentRotation
}}}

then put "?" at the end of the command that fascinates you:
{{{
In : hiro.getCurrentPose?
Type:       instancemethod
Base Class: <type 'instancemethod'>
String Form:<bound method HIRONX.getCurrentPose of <__main__.HIRONX instance at 0x1f39758>>
Namespace:  Interactive
File:       /opt/ros/groovy/lib/python2.7/dist-packages/hrpsys_config.py
Definition: hiro.getCurrentPose(self, lname)
Docstring:  <no docstring>
}}}

Here you know there's a method `getCurrentPose` that takes `lname`, which in this context is easy enough to interpret as `link name`. So run:
{{{
In: hiro.getCurrentPose('RARM_JOINT0')
Out: 
[0.912826202314136,
 -0.4083482880688395,
 0.0,
 0.0,
 0.39443415756662026,
 0.8817224037285941,
 -0.25881904510252074,
 -0.145,
 0.1056883139872261,
 0.2362568060275051,
 0.9659258262890683,
 0.370296,
 0.0,
 0.0,
 0.0,
 1.0]
}}}

`getCurrentPose` returns the rotational matrix and the position of the given link in 1 dimensional list. You could also get only `position`:
{{{
In: hiro.getCurrent
hiro.getCurrentPose      hiro.getCurrentPosition  hiro.getCurrentRPY       hiro.getCurrentRotation
In : hiro.getCurrentPosition('RARM_JOINT0')
Out: [0.0, -0.145, 0.370296]
}}}

In `hrpssy`, position vector is presented as a list with three elements [ y, x, z ] where:
{{{
 y: forward 
 x: left
 z: upward
}}}
 
Now let's move an arm. First go to initial pose.
{{{
In : hiro.goInitial()
}}}

{{{
In : hiro.setTargetPose?
Type:       instancemethod
Base Class: <type 'instancemethod'>
String Form:<bound method HIRONX.setTargetPose of <__main__.HIRONX instance at 0x333b758>>
Namespace:  Interactive
File:       /opt/ros/groovy/lib/python2.7/dist-packages/hrpsys_config.py
Definition: hiro.setTargetPose(self, gname, pos, rpy, tm)
Docstring:  <no docstring>
}}}

`gname` is the name of the `link group`. `pos` and `rpy` are in list format. First, store the current values into variables:
{{{
In : pos = hiro.getCurrentPosition('RARM_JOINT3')
In : rpy = hiro.getReferenceRPY('RARM_JOINT3')
In : tm = 3
}}}

Current `pose` should look like:

http://wiki.ros.org/hironx_ros_bridge?action=AttachFile&do=get&target=hiro_before_move_rarm.png

Then randomly manipulate `position`, and execute:
{{{
In : pos[2] = 0.5

In : hiro.setTargetPose('rarm', pos, rpy, tm)
Out: True
}}}

Now a plan is successfully shown for the right arm to be moved to the specified `pose` like this image:

http://wiki.ros.org/hironx_ros_bridge?action=AttachFile&do=get&target=hiro_after_move_rarm.png

When you're done with the robot,
{{{
In : hiro.goOffPose()
}}}

http://wiki.ros.org/hironx_ros_bridge?action=AttachFile&do=get&target=hiro_powerOff.png

Here are some other methods that could be used with real robot:
{{{
hiro.servoOn
hiro.servoOff
hiro.checkEncoders
hiro.setJointAnglesOfGroup

}}}

=== Operate robot via moveit in Python ===
[http://moveit.ros.org/wiki/MoveIt_Commander moveit_commander] package offers a capability to write a `MoveIt!` client in `Python` ([http://docs.ros.org/hydro/api/moveit_commander/html/annotated.html API doc]). 

To utilize it, you might want to install `MoveIt!`'s python client interface if you already haven't done so.
{{{
$ apt-get install ros-%YOUR_ROS_DISTRO%-moveit-commander
}}}

You can find an example in [https://code.google.com/p/rtm-ros-robotics/source/browse/trunk/rtmros_hironx/hironx_ros_bridge/test/test_hironx_moveit.py test_hironx_moveit.py file in hironx_ros_bridge], which looks like:

{{{
from geometry_msgs.msg import Pose, PoseStamped
from moveit_commander import MoveGroupCommander, conversions
import rospy

rospy.init_node("test_hironx_moveit")

rarm = MoveGroupCommander("right_arm")
larm = MoveGroupCommander("left_arm")

rarm_current_pose = rarm.get_current_pose().pose
larm_current_pose = larm.get_current_pose().pose


def _set_target_random(self):
    '''
    @type self: moveit_commander.MoveGroupCommander
    @param self: In this particular test script, the argument "self" is either
                 'rarm' or 'larm'.
    '''
    global current, current2, target
    current = self.get_current_pose()
    print "*current*", current
    target = self.get_random_pose()
    print "*target*", target
    self.set_pose_target(target)
    self.go()
    current2 = self.get_current_pose()
    print "*current2*", current2

MoveGroupCommander._set_target_random = _set_target_random
}}}

    Here goes cody-by-code explanation:
    {{{
    from geometry_msgs.msg import Pose, PoseStamped
    from moveit_commander import MoveGroupCommander, conversions
    import rospy
    }}}
    Python API of MoveIt! is provided via `moveit_commander.MoveGroupCommander`.
    {{{
    rospy.init_node("test_hironx_moveit")
    rarm = MoveGroupCommander("right_arm")
    larm = MoveGroupCommander("left_arm")
    }}}
    We need to run a ROS `Node` (by calling `rospy.init_node()`) in order to use `MoveGroupCommander` from this script.
    {{{
    rarm_current_pose = rarm.get_current_pose().pose
    larm_current_pose = larm.get_current_pose().pose
    }}}
    Getting current positions.
    {{{
    def _set_target_random(self):
        '''
        @type self: moveit_commander.MoveGroupCommander
        @param self: In this particular test script, the argument "self" is either
                     'rarm' or 'larm'.
        '''
        global current, current2, target
        current = self.get_current_pose()
        print "*current*", current
        target = self.get_random_pose()
        print "*target*", target
        self.set_pose_target(target)
        self.go()
        current2 = self.get_current_pose()
        print "*current2*", current2
    }}}
    Define a method that randomly moves an arm.
    {{{
    MoveGroupCommander._set_target_random = _set_target_random
    }}}
    Latch the method to the class (This is very temporary Python solution and is not specific to `MoveIt!` nor to `Hiro`) so that users can call the method per instance of MoveGroupCommander that is created for each arm.
    
Now usage of that file:

0. This test script assumes that Hiro simulator is always running on your machine (you can do that by following [https://code.google.com/p/rtm-ros-robotics/wiki/hironx_ros_bridge_en this section]).

1. run this script by something like:
{{{
$ ipython -i `rospack find hironx_ros_bridge`/test/test_hironx_moveit.py
}}}

2. On `ipython` interpreter, call either method per arm:
{{{
In : larm._set_target_random()
In : rarm._set_target_random()
}}}

You'll see the planning happens on `RViz`.

For a little more methods available in Python, consult [http://moveit.ros.org/wiki/MoveIt_Commander moveit_commander wiki].

= Troubleshoot =
== With wstool ==
=== ERROR in config: Error processing ===
Upon `wstool update` the error might happen. Try removing the folder you're getting error with.

At the moment, a lot of tweaks are needed [http://code.google.com/p/rtm-ros-robotics/issues/detail?id=175 as reported in this thread].

== hrpsys_ros_bridge fails to build ==
-------------------------------------------------------------------------------}
[ rosmake ] Output from build of package hrpsys_ros_bridge written to:
[ rosmake ]    /home/leus/.ros/rosmake/rosmake_output-20130823-115337/hrpsys_ros_bridge/build_output.log
[rosmake-0] Finished <<< hrpsys_ros_bridge [FAIL] [ 143.86 seconds ]                                                           
[ rosmake ] Halting due to failure in package hrpsys_ros_bridge. 
[ rosmake ] Waiting for other threads to complete.           
[ rosmake ] Results:                                                                                                           
[ rosmake ] Built 75 packages with 1 failure

(roscd hrpsys_ros_bridge; make)

== AttributeError: 'module' object has no attribute 'get_sysinfo' ==

{{{
$ simulation.launch 
:
Traceback (most recent call last):
  File "/home/leus/ros/groovy/rtm-ros-robotics/rtmros_common/hrpsys_ros_bridge/scripts/rtmlaunch", line 3, in <module>
    import os,psutil,subprocess,socket,sys
  File "/opt/ros/groovy/lib/python2.7/dist-packages/psutil/__init__.py", line 65, in <module>
    import psutil._pslinux as _psplatform
  File "/opt/ros/groovy/lib/python2.7/dist-packages/psutil/_pslinux.py", line 90, in <module>
    TOTAL_PHYMEM = _psutil_linux.get_sysinfo()[0]
AttributeError: 'module' object has no attribute 'get_sysinfo'
}}}

If you see this error,
{{{
$ sudo apt-get remove ros-groovy-rqt-top
}}}

== No moveit! found? ==
{{{
$ roslaunch hironx_moveit_config moveit_planning_execution.launch
}}}

If you see error with this, then:

{{{
$ sudo apt-get install ros-groovy-moveit-full-pr2
}}}

== [rospack] Error: stack/package collada_tools not found ==
{{{
[rospack] Error: stack/package collada_tools not found
make[2]: *** [/home/leus/catkin_ws/src/rtmros_hironx/hironx_moveit_config/models/HiroNX.urdf] Error 2
make[1]: *** [rtmros_hironx/hironx_moveit_config/CMakeFiles/hironx_moveit_config_HiroNX_urdf.dir/all] Error 2
}}}
Then do:
{{{
$ mv src/rtmros_hironx .
}}}

== [rospack] Error: package/stack 'collada_tools' depends on non-existent package ==
{{{
[rospack] Error: package/stack 'collada_tools' depends on non-existent package 'colladadom' and rosdep claims that it is not a system dependency. Check the ROS_PACKAGE_PATH or try calling 'rosdep update'
}}}
Then comment out in `collada_tools/manifest.xml`:
{{{
<!-- <depend package="colladadom"/> -->
}}}

== rtm/idl/SDOPackageSkel.h:35:33: Fatal: rtm/idl/SDOPackage.hh: ==
{{{
$ rosmake hironx_ros_bridge
../../../../src/lib/rtm/idl/SDOPackageSkel.h:35:33: Fatal: rtm/idl/SDOPackage.hh: not found
}}}
Then,
{{{
$ rosdep install hironx_ros_bridge
}}}

Then before rosmake-ing,
{{{
$ roscd openrtm_aist
$ make clean
}}}

== Halt at [hrpsys.py]  waiting ModelLoader ==
When you run and see:
{{{
$ roscd hironx_ros_bridge/scripts
$ ./hironx.py
[hrpsys.py]  waiting ModelLoader
}}}

Then define environmental variable by running:
{{{
export RTCTREE_NAMESERVERS=localhost:5005
export ORBInitRef="NameService=corbaloc:iiop:localhost:15005/NameService"
}}}

== run_id on parameter server does not match declared run_id: ==
If you see a message like this while trying to run with MoveIt!, check if your computer is able to communicate with your real robot.
{{{
run_id on parameter server does not match declared run_id: e6ff428e-0ec8-11e3-a8cf-88532e0fe6e6 vs e8491bd8-0ec8-11e3-9deb-88532e0fe6e6
}}}

== Upon initialization "TRANSIENT: CORBA.TRANSIENT" ==
{{{
TRANSIENT: CORBA.TRANSIENT(omniORB.TRANSIENT_ConnectFailed, CORBA.COMPLETED_NO)
}}}

Run hironx by:
{{{
$ rtmlaunch hironx_ros_bridge hironx_startup.launch
}}}