#summary 画像処理のサンプル

[ROS_Example ROSサンプル]

== 概要 ==
画像処理のサンプルプログラムを例にしつつ，ノード，トピック，リマップ，メッセージ
<wiki:comment>
，サービス，パラメータ
</wiki:comment>
等の概念を紹介する．

== 準備 ==

=== 新しいソースのインストールと動作確認 ===
{{{
cd ~/prog/rtm-ros-robotics/agentsystem_ros_tutorials
svn up
rosinstall ~/prog/rtm-ros-robotics /opt/ros/diamondback ~/prog/rtm-ros-robotics/agentsystem_ros_tutorials/rtm-ros-robotics.rosinstall
}}}
とすると，新しいソースがインストールされる．このとき
ROSの起動に必要な環境変数が更新されるため，既に立ち上がっている
ターミナルでは
{{{
source ~/.bashrc
}}}
とすること．新たにターミナルを起動する場合はこの必要はない．
一度，全てのターミナルを消して，新たに立ち上げることを勧める．

  * rosinstallについて

  ROSのインストールは`.rosinstall`ファイルで設定する．
  ファイルフォーマットに関して，詳しい情報は，http://www.ros.org/wiki/rosinstall を見てみよう．ただ，
{{{
$ roslocate info icra_ros_tutorial
- svn:
        local-name: icra_ros_tutorial
        uri: https://code.ros.org/svn/wg-ros-pkg/branches/trunk_boxturtle/sandbox/icra_ros_tutorial
}}}
  のようにパッケージ名を知っていれば`roslocate`コマンドで必要な設定情報を知ることが出来る．また，どのようなリポジトリが有るかについてはhttp://www.ros.org/browse/list.php のページを見るとよい．

  ここにかかれたソースをダウンロードし，必要な環境変数を`setup.bash`(実際はこのファイルから呼ばれる`setup.sh`)に書き出している．この環境変数が無いとROSは動かないため，かならずこのファイルをロードしているか確認すること．

ソフトウェアのインストールが出来たら，
{{{
rosmake roseus_tutorials --rosdep-install　--rosdep-yes
roscore
}}}
とし，もう一つのターミナルを開いて
{{{
roslaunch roseus_tutorials usb-camera.launch 
}}}
（ここで，`[ WARN] [1303720226.445781085]: Started in the global namespace!` とか，`ERROR: could not set some settings.`とか，`select timeout in grab`とか表示されても気にしなくてよい）

さらにもう一つターミナルを開いて，
{{{
roslaunch roseus_tutorials image-view.launch 
}}}
とすると，カメラ画像が見えるはずである．

最後に
{{{
rxgraph
}}}
としてみよう．以下のような画面が現れるはずだ．
[http://rtm-ros-robotics.googlecode.com/svn/wiki/roseus_tutorials_camera_view_rxgraph.png]

丸で囲まれたものが*[http://www.ros.org/wiki/Nodes ノード]*を示し，それらの間の矢印が*[http://www.ros.org/wiki/Topics トピック]*を表す．ノードはプロセスと同義であり，トピックはノード間でメッセージ（データ型）を交換するための名前付きバスである．ノードはトピックをSubscribeあるいは，Publishする．

`rosnode list`とすると，現在のノードの一覧が，`rostopic list`とすると，現在のトピック一覧を見ることができる．`rostopic echo /image_rect_color/screenpoint`とすると，カメラ画像をクリックする度に表示されるはずだ．
カメラ画像はクリックされる度に`/image_rect_color/screenpoint`というトピックをパブリッシュし，`rostopic echo`は，`/image_rect_color/screenpoint`というトピックをサブスクライブし結果を表示している，ということになる．

  * ROSカメラドライバについて
  ちなみに，ROSのUSBカメラドライバは各種存在する．それぞれについては，[http://www.iheartrobotics.com/2010/05/testing-ros-usb-camera-drivers.html Testing: ROS USB Camera drivers]に詳しい．また，これらのドライバを統一してサポートするバージョンを作っていこうという[http://ros-users.122217.n3.nabble.com/call-for-an-official-ROS-USB-camera-package-td2116581.html 議論]もあるので注意が必要な段階である．

  一方，IEEE1394カメラについては，以前は同様に各種存在する段階だったが今は[http://www.ros.org/wiki/camera1394 統合されたバージョン]に落ち着いている段階にある．その際の[http://www.ros.org/wiki/camera1394/Reviews 議論の過程]を見ることが出来る．

== 簡単なサンプルプログラム ==

* 基本となるサンプルプログラム

簡単なサンプルプログラムをopencv_ros_bridge_tutorialに置いた．
新しいソースのインストールと動作確認の所で実行した
{{{
roscore
roslaunch roseus_tutorials usb-camera.launch 
}}}
を立ち上げたまま，まず，
{{{
rosrun opencv_ros_bridge_tutorial image_painter image:=/image_rect
}}}
とし，さらに別のターミナルで
{{{
rosrun image_view2 image_view2 image:=/image_painted
}}}
とすると，画面の左上に小さい丸が表示されているはずである．

`image:=/image_rect`の部分は*[http://www.ros.org/wiki/Remapping%20Arguments リマップ]*と呼ばれる大変便利な機能である．
これはプログラム中に埋め込まれたトピック名等の名前を，プログラムの実行時に変更することが出来，これにより同じノードを複数の設定で実行することが出来る．例えば，このプログラムのコードでは` it_.subscribe("image", 1, &ImagePainter::imageCb, this);`と`image`という名前のトピックをSubscribeしているが，上の様に実行することで`image_rect`という名前のトピックをSubscribeするよう設定し実行している．


プログラムの中身の詳細の説明は,[http://www.ros.org/wiki/cv_bridge/Tutorials/UsingCvBridgeToConvertBetweenROSImagesAndOpenCVImages]に譲るが，ポイントはプログラムの中段の以下の部分．
{{{
    if (cv_ptr->image.rows > 60 && cv_ptr->image.cols > 60)
      cv::circle(cv_ptr->image, cv::Point(30, 50), 10, CV_RGB(0,0,255));

    cv::imshow(WINDOW, cv_ptr->image);
    cv::waitKey(3);

    image_pub_.publish(cv_ptr->toImageMsg());
}}}
OpenCVの`cv_ptr->image`が`cv::Mat`型であるので，通常のOpenCV画像処理プログラムを記述すればよい．

* トピックのサブスクライブ

視野画像をクリックすると，その場所に丸を書くようにプログラムを変更しよう．そのためには，`image_rect/screenpoint`をSubscribeすればよい．
プログラムは`image_painter2.cpp`にある．

まずは，
{{{
rostopic info /image_painted/screenpoint
}}}
としてトピックの型を調べる．これで，`Type: geometry_msgs/PointStamped`という情報が得られる．(
さらに，`rosmsg show geometry_msgs/PointStamped`とすると，型の情報を知ることが出来る）

ここから，プログラムの先頭に
{{{
#include <geometry_msgs/PointStamped.h>
}}}
としてファイルをインクルードし，
{{{
    screen_sub_ = nh_.subscribe("/image_painted/screenpoint", 1, &ImagePainter::screenCb, this);
}}}
として，Subscribeする．`screenCb`の中は
{{{
  void screenCb(const geometry_msgs::PointStampedPtr& msg)
  {
    ROS_INFO("screen cb %3d %3d", (int)msg->point.x, (int)msg->point.y);
    screen_x = msg->point.x; screen_y = msg->point.y;
  }
}}}
として，メッセージを受け取る度にこの関数が呼ばれることになる．
`screen_x`, `screen_y`がメンバ変数であり，imageCbの中で
{{{
    cv::circle(cv_ptr->image, cv::Point(screen_x, screen_y), 10, CV_RGB(0,0,255));
}}}
として，メッセージに応じた位置にcircleを描画する様になっている．

`imgae_painter`の代わりに`image_painter2`を実行するためには
{{{
rosrun opencv_ros_bridge_tutorial image_painter2 image:=/image_rect
}}}
として立ち上げればよい．この時点で，これに加えて
{{{
roscore
roslaunch roseus_tutorials usb-camera.launch 
rosrun image_view2 image_view2 image:=/image_painted
}}}
の4つのターミナルが立ち上がっているはずである

後は，視野画像をクリックすればその位置に丸がかかれることになる．

このプログラム（ノード）は，どのノードが出力(publish)したかに関わらず'/image_painted/screenpoint'という名前のトピックを受け取るようになっている．したがって，例えば
{{{
rostopic pub -1 /image_painted/screenpoint geometry_msgs/PointStamped '{point: {x: 100, y: 200}}'
}}}
というコマンドラインを使ってもよいし，Pythonユーザなら
{{{
import roslib; roslib.load_manifest('opencv_ros_bridge_tutorial')
import rospy;
import math;
from geometry_msgs.msg import PointStamped

pub = rospy.Publisher('/image_painted/screenpoint', PointStamped)
rospy.init_node('publish_screenpoint')
msg = PointStamped()
i = 0;
while not rospy.is_shutdown():
    msg.point.x = 320 + 180*math.sin(i)
    msg.point.y = 240 + 180*math.cos(i)
    i += 0.1
    print msg;
    pub.publish(msg)
    rospy.sleep(0.1)
}}}
とかける．C++だと，
{{{
#include "ros/ros.h"
#include "geometry_msgs/PointStamped.h"

#include <math.h>

int main(int argc, char **argv)
{
  ros::init(argc, argv, "publish_screenpoint");

  ros::NodeHandle n;
  ros::Publisher pub = n.advertise<geometry_msgs::PointStamped>("/image_painted/screenpoint", 1000);

  ros::Rate loop_rate(10);
  double i = 0;
  while (ros::ok())
    {
      geometry_msgs::PointStamped msg;
      msg.point.x = 320 + 180*sin(i);
      msg.point.y = 240 + 180*cos(i);
      i += 0.1;
      ROS_INFO("%5.1f %5.1f", msg.point.x, msg.point.y);
      pub.publish(msg);
      ros::spinOnce();
      loop_rate.sleep();
    }

  return 0;
}
}}}
として，CMakeLists.txtに`rosbuild_add_executable(publish_screenpoint src/publish_screenpoint.cpp)`を追加しコンパイルし実行する必要が有る．euslispだと，
{{{
#!/usr/bin/env roseus                                                           

(ros::load-ros-manifest "opencv_ros_bridge_tutorial")
(ros::roseus "publish_screenpoint")
(ros::advertise "/image_painted/screenpoint" geometry_msgs::PointStamped 1)
(setq i 0)
(ros::rate 10)
(while (ros::ok)
 (setq msg (instance geometry_msgs::PointStamped :init))
 (send msg :point :x (+ 320 (* 180 (sin i))))
 (send msg :point :y (+ 240 (* 180 (cos i))))
 (incf i 0.1)
 (ros::ros-info "msg ~A ~A" (send msg :point :x) (send msg :point :y))
 (ros::publish "/image_painted/screenpoint" msg)
 (ros::sleep))
}}}
となる．それぞれ`opencv_ros_bridge_tutorial/src/`にコードがあり，
{{{
roscd opencv_ros_bridge_tutorial
./src/publish_screenpoint.sh
./src/publish_screenpoint.py
./bin/publish_screenpoint
./src/publish_screenpoint.l
}}}
として実行出来る．

Publish, Subscribeの仕方について，より詳しくは [
http://www.ros.org/wiki/ROS/Tutorials/WritingPublisherSubscriber%28c%2B%2B%29] をみよう．

<wiki:comment>
* サービスコールの扱い
</wiki:comment>

その他のより詳しい情報は[http://www.ros.org/wiki/ROS/Tutorials]にある．