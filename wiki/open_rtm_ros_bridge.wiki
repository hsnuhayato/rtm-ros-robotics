#summary One-sentence summary of this page.
open_rtm_ros_bridge for hiro

[http://ros.org/doc/api/openrtm_ros_bridge/html/]
this converts idl file to ros srv file and generate Python ros component that
provides ROS service interfacing to OpenRTM service. This means that
if you have existing OpenRTM service (in your case, hiro ik service), the
system automatically generate ROS service node that you can call service
from your ros python code.


=Installation and testing=

{{{
$ rosmake openrtm_ros_bridge
}}}

===Testing ===

1:
{{{
$ roslaunch openrtm_ros_bridge myservice_example.launch
Then
$ roslaunch openrtm_ros_bridge myservice_rosbridge.launch
should be ok. you can see three openrtm components as
http://ros.org/doc/api/openrtm_ros_bridge/html/_images/service-rosbridge.png
}}}

after that, you can call openrtm service from ros command
{{{
$ rosservice  list
$ rosservice call /bridge/echo "hello , this is echo sample"
}}}
2:
then 

{{{
$ roscd hrpsys
}}}
open CMakeList.txt. You will find the function
{{{
 rtmbuild_genbridge()
}}}
It converts all idl files to msg/srv with make
command and generate ROSBridge source code under src_gen directory.

*hrpsys/sample/hrp4c-rosbridge.launch* is the example.
first select ServiceBridgeComponent for corresponding OpenRTM
service under src_gen directory
{{{
  <node name="SequencePlayerServiceROSBridgeComp" pkg="hrpsys"
type="SequencePlayerServiceROSBridgeComp"
        args='$(arg openrtm_args)'>
    <param name="service_port" value="service0"/>
  </node>
}}}
and then you modify rtactivate and rtconnect tag for your Bridge Component


== Example for ArmControService.idl ==

{{{
$ roscreate-pkg hiro_rtm_service_ros_bridge
}}}
Edit manifest to:
{{{
<package>
  <description brief="hiro_rtm_service_ros_bridge">

     hiro_rtm_service_ros_bridge

  </description>
  <author>Urko Esnaola</author>
  <license>BSD</license>
  <review status="unreviewed" notes=""/>
  <url>http://ros.org/wiki/hiro_rtm_service_ros_bridge</url>
  
  <depend package="roscpp"/>
  <depend package="openrtm_ros_bridge"/>

</package>
}}}

{{{
$ roscd hiro_rtm_service_ros_bridge
$ mkdir idl
$ cp <rtm_idl_locaton>/ArmControlService.idl idl
}}}

edit CMakeList.txt add rtmbuild_init() (comment rosbuild_init()) add rtmbuild_genidl() and rtmbuild_genbridge()

{{{
cmake_minimum_required(VERSION 2.4.6)
include($ENV{ROS_ROOT}/core/rosbuild/rosbuild.cmake)
rosbuild_find_ros_package(rtmbuild)
include(${rtmbuild_PACKAGE_PATH}/cmake/rtmbuild.cmake)

# Set the build type.  Options are:
#  Coverage       : w/ debug symbols, w/o optimization, w/ code-coverage
#  Debug          : w/ debug symbols, w/o optimization
#  Release        : w/o debug symbols, w/ optimization
#  RelWithDebInfo : w/ debug symbols, w/ optimization
#  MinSizeRel     : w/o debug symbols, w/ optimization, stripped binaries
#set(ROS_BUILD_TYPE RelWithDebInfo)

#rosbuild_init()
rtmbuild_init()

#set the default path for built executables to the "bin" directory
set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin)
#set the default path for built libraries to the "lib" directory
set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)

#uncomment if you have defined messages
#rosbuild_genmsg()
#uncomment if you have defined services
#rosbuild_gensrv()
rtmbuild_genidl()

#common commands for building c++ executables and libraries
#rosbuild_add_library(${PROJECT_NAME} src/example.cpp)
#target_link_libraries(${PROJECT_NAME} another_library)
#rosbuild_add_boost_directories()
#rosbuild_link_boost(${PROJECT_NAME} thread)
#rosbuild_add_executable(example examples/example.cpp)
#target_link_libraries(example ${PROJECT_NAME})

##
## tools
##


rtmbuild_genbridge()

}}}

make:
{{{
$ rosmake hiro_rtm_ros_bridge
}}}

Create launch file launch/hiro_rtm_service_ros_bridge.launch

{{{
<launch>
  <!-- BEGIN:openrtm setting -->
  <arg name="nameserver" default="10.254.19.1" />
  <env name="RTCTREE_NAMESERVERS" value="$(arg nameserver)" />
  <arg name="openrtm_args" value='-o "corba.nameservers:$(arg nameserver):2809" -o "naming.formats:%n.rtc" -o "logger.file_name:/tmp/rtc%p.log" ' />
  <!-- END:openrtm setting -->

  <!-- Hiro Service Bridge component -->
  <node name="ArmControlServiceROSBridgeComp" pkg="hiro_rtm_service_ros_bridge" type="ArmControlServiceROSBridgeComp"
        args='$(arg openrtm_args)'>
    <param name="service_port" value="service0"/>
  </node>

  <!-- BEGIN:openrtm connection -->     
    <node name="rtmlaunch_rosbridge" pkg="openrtm" type="rtmlaunch.py"
          args="$(find hiro_rtm_service_ros_bridge)/launch/hiro_rtm_service_ros_bridge.launch"/>

  <rtactivate component="ArmControlServiceROSBridge0.rtc" />
  <rtconnect from="ArmControlServiceROSBridge0.rtc:ArmControlService" 
             to="armR.rtc:ArmControlService"/>

  <!-- END:openrtm connection -->


</launch>
}}}
 
