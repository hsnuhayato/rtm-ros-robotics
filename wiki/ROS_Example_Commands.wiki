#summary ROSの主なコマンド

<wiki:toc max_depth="2" />

= 概要 =
[ROS_Install  ROSのインストール]が終わっていることを前提とさせていただきます。
ROSの主なコマンドの紹介です。
詳しくは、ROSのページを参考に見に行ってください。
おそらく、ここで紹介するのは、とりあえずどんなコマンドがあるかを知るため
程度と思ってください。

= なぜ特別にros用のコマンドがあるのか =
パッケージごとに扱うことが多いrosでは、どこのディレクトリにいてもパッケージにアクセスすることを容易にするためにさまざまな便利なros用のコマンドがあります。パッケージ名を知っていれば、引数にパッケージの名前を与えるだけで、そのパッケージの場所に移動したり、移動せずにその中のパッケージの中をみたり編集したりすることができます。今は、おそらくありがたみがわからないと思いますが、使うとかなり便利です。

= コマンドのテーブルでの概略機能紹介 =
なるべくよく使うであろう順番に並べてあります。まだROSの習いはじめで、
どんなコマンドがあるのかもわからないときに参照してください。
||[#roscd roscd] || ディレクトリを移動する||
||[#rosls rosls] || ディレクトリの中を表示する||
||[#rosmake rosmake]|| makeを依存関係を含めmakeを行ってくれる||
||[#rosws rosws]|| パッケージのアップデートなどを行う||
||[#roscore roscore]|| rosのOSのような機能を起動する||
||[#rxgraph rxgraph]|| 起動されているnodeやtopicの関係を図式化する||
||[#rosrun rosrun]|| プログラムを実行する||
||[#roslaunch roslaunch]|| launchファイルを実行する(複数のrosrunを一気に行うようなもの)||
||[#rostopic rostopic]|| topicに関する情報を得る||
||[#rospack rospack]|| packageに関する情報を得る||
||[#roscreate-pkg roscreate-pkg]||　新たにパッケージを作る||
||[#rosmsg rosmsg]|| メッセージに関する情報を得る||
||[#roslocate roslocate]|| パッケージのインストールに関する情報等を得る||
||[#roscp roscp]|| コピーをする||
||[#rosnode rosnode]|| ノードに関する情報を得る||
||[#rosed rosed]|| viかemacsのエディタをコマンドに開く||

= 大まかなコマンド紹介 =
あくまでここでも概略しか紹介していません。
それぞれの詳しい情報は本来のROSのページを参照しにいってください。
-----
-----
==roscd==
[http://www.ros.org/wiki/ROS/Tutorials/NavigatingTheFilesystem ROSのroscd]を詳しくは参照してください。

ディレクトリを移動するコマンドです。

引数はパッケージ名を指定すればよく、もしその下の階層のディレクトリに移動したい場合は、さらに、そのフォルダの名前を指定してください。
===主に使う形===
{{{
    roscd パッケージ名
ex) roscd roseus_tutorials/bin
}}}
のように使います。パッケージはROS_PACKAGE_PATHにパスが通ってなくてはなりません。

===参考===
{{{
roscd
}}}
のみ打った場合は、workSpaceのディレクトリに戻ります。workSpaceのディレクトリは環境変数で以下の様に設定されているのが確認できます。一行目を打ってください。
{{{
$env | grep ROS
ROS_WORKSPACE=/home/mechuser/ros/fuerte
}}}
-----
-----
==rosls==
[http://www.ros.org/wiki/ROS/Tutorials/NavigatingTheFilesystem ROSのrosls]を詳しくは参照してください。

ディレクトリの中のものを表示するコマンドです。通常のlsと同じような機能です。

引数はパッケージ名をしてすればよく、もしその下の階層のディレクトリを表示したい場合は、さらに、そのフォルダの名前を指定してください。

ディレクトリを移動しないでも中を見れるのが強みです。
===主に使う形===
{{{
    rosls パッケージ名
ex) rosls roseus_tutorials/build
}}}
のように使います。パッケージはROS_PACKAGE_PATHにパスが通ってなくてはなりません。

===参考===
{{{
rosls -latr
rosls
}}}
通常通りのオプションをつけることもできますし、何も引数を与えない場合はlsと同じくカレントディレクトリの内容を表示します。
-----
-----
==rosmake==
[http://www.ros.org/wiki/rosmake ROSのrosmake]を詳しくは参照してください。

パッケージのmakeを依存関係などを含めてすべて行ってくれる便利なコマンドです。かなりmakeには時間がかかると思いますので、辛抱強く待ってみてください。

makeに新たに加えたいものがある場合は、CMakeLists.txtの中を変更しなくてはなりません。
===主に使う形===
{{{
    rosmake パッケージ名
ex) rosmake roseus_tutorials
}}}
===参考===
あるパッケージAのプログラムを実行したときに、他のパッケージBの文句が言われた場合には、パッケージBが古いか、makeされてないことが多々あると思います。そしたら、以下の様に行って見てください
{{{
//パッケージがsvnで押されている場合
$svn up
$rosmake パッケージB
}}}
-----
-----
==rosws==
[http://www.ros.org/wiki/rosws ROSのrosws]を詳しくは参照してください。
===主に使う形===
===参考===
-----
-----
==roscore==
[http://www.ros.org/wiki/roscore ROSのroscore]を詳しくは参照してください。

rosの起動のような機能にあたるようなもので、ほかのどのnodeを立てるときも必ずまず、roscoreはどこかのターミナルでひとつだけ開いといてください。逆に複数は開けず一つしか開けないようになっています。実際はこれによって、masterとrosoutとparameterServerが走り始めます。

実機ではなく自分のパソコンで、シュミレーションなどを行う際に、必ず起動しておいてください。
===主に使う形===
{{{
roscore
}}}
-----
-----
==rxgraph==
[http://www.ros.org/wiki/rxgraph ROSのrxgraph]を詳しくは参照してください。

これは、nodeやtopicなどの関係を図式化するコマンドです。初めのうちは重宝すると思うので、使ってみてください。


===主に使う形===
表示したいプログラムを動かしている状態で、新しいターミナルで以下を実行します。
{{{
rxgraph
}}}
===参考===
基本を終えて、例えばkinectなどを用い始めるとnodeが数１０個などと平気で立ち上がってしまい、topicの数もそれと同じくたくさんたってしまうので、図がぐちゃぐちゃになってしまい関係がわからず、実用性がなくなります。増えてきたら、rostopicなどを使ってみましょう。

-----
-----
==rosrun==
[http://www.ros.org/wiki/rosrun ROSのrosrun]を詳しくは参照してください。

一つの実行ファイルやスクリプトを実行し、nodeを立ち上げるためのコマンドです。

c++とpython、lispも同じように実行することができます。

[http://code.google.com/p/rtm-ros-robotics/wiki/ROS_Install#実行に際して（困ったときに） 実行に際して]で実行の仕方について書いてありますので、よかったら参考にしてみてください。


===主に使う形===
{{{
    rosrun パッケージ名 ファイル名
ex) rosrun roseus_tutorials camshiftdemo.l
    rosrun roscpp_tutorials listener
    rosrun rospy_tutorials listener.py
}}}
のように使います。パッケージはROS_PACKAGE_PATHにパスが通ってなくてはなりません。

これがもっとも一般的な使い方です。

ほかにリマップという機能を使ったものもあります。
{{{
rosrun image_view image_view image:=/camera/image
}}}
というように書いて、topicの読込先を差し替えることができます。


===参考===
rosrunでは立ち上げるプログラムそれぞれ特有のパラメータの値を設定することができます。

たとえば、image_viewという画像データを受け取って画面を作り表示するプログラムを実行するときには以下のようにできます（指定しないとデフォルト値が入ります）。
{{{
rosrun image_view image_view _window_name:="image_view2"
}}}
ここでは、image_viewのもともと設定できるとわかっている_window_nameに"image_view2"を設定しています。

自分でプログラムを書く際はもちろん、どんなパラメータを設定してもらうかをコードの中に書くことで決めることができます。このimage_viewもどのようなパラメータがあるかはあらかじめ決められてます。以下は[http://www.ros.org/wiki/image_view ROSのimage_view]のページからとってきたものです。
{{{
Parameters

~autosize (bool, default: false)
Whether the window should autosize itself to the image or be resizeable by the user.
~filename_format (string, default: "frame%04i.jpg")
printf-style format for saved image names. Use to control name, location and format of saved images.
~image_transport (string, default: "raw")
Transport used for the image stream. image_view allows you to specify this as a simple command-line argument for convenience.
~window_name (string, default: name of the image topic)
The name of the display window.
}}}

ほかのROSの用意されているnodeを用いる場合も同じようにROSのページを探してみてください。


あと、もう一点、nodeを立ち上げるときの情報もいくらか編集することができ、例えば、同じプログラムを複数立ち上げたいときは、以下のようにしてデフォルトのnode名を変えることができます。
{{{
rosrun roscpp_tutorials listener __name:="listener23456"
}}}

-----
-----
==roslaunch==
[http://ros.org/wiki/roslaunch ROSのroslaunch]を詳しくは参照してください。

.launchファイルというXML形式でかかれたさまざまな複数のnodeをパラメータを決めたりリマップをしつつ起動することについて書かれているファイルを実行する。

rosrunとの違いは上にも書いたように、何度もrosrunを行わずに起動すべきnodeを.launchファイルに書いておけばすべてを一度のコマンドで実行してくれるという点である。また、設定の変更、リマップも容易に行うことができる点もある。

ここでnodeの書かれている順番は、nodeが起動される順番とは関係ないので、各プログラムは起動順番にロバストである必要がある。
以下がkinect.launchファイルの中身の一例である。
{{{
<launch>
  <include file="$(find openni_launch)/launch/openni.launch">
    <!--arg name="camera" value="openni"/-->//この部分はコメントアウトされてます。
    <arg name="respawn" value="true"/>
    <arg name="publish_tf" value="true"/>
  </include>

  //openni_trackerのパッケージからnodeを立ち上げます。
  <node name="openni_tracker" pkg="openni_tracker" type="openni_tracker" output="screen" respawn="true" >
    <param name="camera_frame_id" value="camera_depth_frame"/>//これがパラメータを決めている部分
  </node>
  //image_viewのパッケージからnodeを立ち上げます。
  <node name="openni_dispairty_view" pkg="image_view" type="disparity_view">
    <remap from="image" to="/camera/depth/disparity" />//これがリマップを行っている部分
  </node>
  <node name="map_openni_camera" pkg="tf" type="static_transform_publisher"
        args="0 0 1.5 0 0 0 /map /camera_link 100" />
</launch>

}}}

.launchファイルの文法について知りたい場合は、[http://code.google.com/p/rtm-ros-robotics/wiki/ROS_Example_ROS_TUTORIALS ROSのroslaunch文法]を見にいっていただければと思います。そのTagReferenceを読めば大事なことがわかると思います。
===主に使う形===
{{{
roslaunch roseus_tutorials kinect.launch
}}}
でおしまいです。これで一気に３つほどのnodeを立ち上げプログラムを実行してくれます。
===参考===
コマンドを打っているときにTABによる補完ももちろんしてくれます。
-----
-----
==rostopic==
[http://www.ros.org/wiki/rostopic ROSのrostopic]を詳しくは参照してください。

topicの情報をさまざまに表示するものです。topicについてはmsg（メッセージ）を勉強したらわかると思います。

===主に使う形===
{{{
rostopic    //このままではなにもされません。
}}}
上記のコマンドではなにもされませんが、とりあえず打ってみてください。そうすると以下のようにUsageを表示してくれると思います。
{{{
rostopic is a command-line tool for printing information about ROS Topics.

Commands:
	rostopic bw	display bandwidth used by topic
	rostopic echo	print messages to screen
	rostopic find	find topics by type
	rostopic hz	display publishing rate of topic    
	rostopic info	print information about active topic
	rostopic list	list active topics
	rostopic pub	publish data to topic
	rostopic type	print topic type

Type rostopic <command> -h for more detailed usage, e.g. 'rostopic echo -h'

}}}
というように表示されると思います。rostopicは主にこれらの引数のどれかを指定して、何か情報を引き出すことになります。
もう勉強しているとは思いますが、よく使うものだけを見ていきたいと思います。


ここでは、roscpp_tutorialsのtalkerとlistenerを用いて、例を示してみたいと思います。
{{{
roscore
}}}
および、
{{{
rosrun roscpp_tutorials talker
}}}
と
{{{
rosrun roscpp_tutorials listener
}}}

をそれぞれ違うターミナルで実行してください。
おそらく、talkerを実行したターミナルに以下のような表示が流れているかと思います。
{{{
[ INFO] [1353898053.206074705]: hello world 1425 //あくまで例です。
}}}

まず、この状態では、何のtopicがあるかわかりません。
そこで、以下を実行して、すべてのtopicを表示します。
{{{
rostopic list
}}}
そうすると以下のようなリストが見れると思います。
{{{
/chatter      //talkerが作っているtopic
/rosout       //roscoreが作っているtopic
/rosout_agg   //・・・
}}}
これらのうち/chatterが今注目したい目的のtopicです。ここでターミナルでrxgraphを実行したら、視覚的にどのようにnodeがつながっているかわかります。rxgpaphでnode同士をつないでいる線に書いてある名前がtopicです。

今は、rxgraphで関係が確認ができますが、多くのプログラムでは、nodeが大量にたち、それぞれを結ぶ線が混雑しやすいため、rxgraphは役に立ちません。

そこで、次に誰がそのtopicを出していて、誰が受け取っているかを見てみます。
{{{
   rostopic info topic名
ex)rostopic info /chatter
}}}
を打ち込むと以下のように表示されると思います。
{{{
Type: std_msgs/String

Publishers: 
 * /talker (http://ubuntu:50585/)

Subscribers: 
 * /listener (http://ubuntu:34085/)
}}}
ここでの情報を整理すると
 * メッセージのタイプはstd_msgs/Strinig
 * topicにパブリッシュしている（情報を送り出している）のはtakler
 * topicからサブスクライブしている(情報を取得している)のはlistener
とのことがわかります。

単に一つ目のtypeだけ知りたければ、以下のようにしてください。
{{{
rostopic type /chatter
}}}
結果は以下のようになります。
{{{
std_msgs/String
}}}

今は、どんな情報が来ているかはlistenerで形を加工しているものの表示させているため目でデータがしっかりと届いていることが確認することができますが、多くのプログラムでは、その内容をわざわざ表示することはそう多くありません。そこで、ターミナルに表示させたいときは以下のコマンドを使ってください。
{{{
   rostopic echo topic名
ex)rostopic echo /chatter
}}}
ここでは以下のようなものが見れます。

{{{
data: hello world 11299
}}}
これでtopicに届いている情報の内容がわかりました。

逆に、今度は、どんな情報のタイプが着ているかはわかっているけど、topic名がわからない場合を考えます。その際は
{{{
rostopic find std_msgs/String
}}}
と打ってみてください。そうすると
{{{
/chatter
}}}
と表示され、しっかりtopicが確認できると思います。

===参考===
rostopicは、コマンドを打ってる最中にTABキーを押すと探しているtopic名があれば自動で補完してくれますが、実機ではかなり反応に時間がかかるので使わないほうがいいかもしれません。

-----
-----
==rospack==
[http://www.ros.org/wiki/rospack ROSのrospack]を詳しくは参照してください。

rospackの使い方は、ほとんどpackageのパスを表示するぐらしか使いません。
===主に使う形===
{{{
    rospack find パッケージ名
ex) rospack find roseus_tutorials
}}}
-----
-----
==roscreate-pkg==
[http://www.ros.org/wiki/roscreate ROSのroscreate-pkg]を詳しくは参照してください。

roscreate-pkgはパッケージの依存関係を記すのに必要なmanifest.xmlやmakeに必要なCMakeLists.txtや、そのほか必要なものをすべてパッケージの名前の指定のみで用意を行ってくれる便利なコマンド。要するに依存関係とともにパッケージを作るコマンド。

===主に使う形===
{{{
    roscreate-pkg 新規パッケージ名　依存パッケージ１　依存パッケージ２　・・・
ex) roscreate-pkg my_package        std_msgs
}}}
以上のようにすると、std_msgsを依存するパッケージとして新しくmy_packageというパッケージを作成する。これはROS_PACKAGE_PATHの通っているディレクトリで行わないとうまくいかない。
===参考===
roscreate-stackというものもあるが、これはスタックを使うものである。
-----
-----
==rosmsg==
[http://www.ros.org/wiki/rosmsg ROSのrosmsg]を詳しくは参照してください。
===主に使う形===
===参考===
-----
-----
==roslocate==
[http://www.ros.org/wiki/roslocate ROSのroslocate]を詳しくは参照してください。
===主に使う形===
===参考===
-----
-----
==roscp==
[http://www.ros.org/wiki/ROS/Tutorials/CreatingMsgAndSrv ROSのroscp]を詳しくは参照してください。
===主に使う形===
===参考===
-----
-----
==rosnode==
[http://www.ros.org/wiki/rosnode ROSのrosnode]を詳しくは参照してください。
===主に使う形===
===参考===
-----
-----
==rosed==
[http://www.ros.org/wiki/ROS/Tutorials/UsingRosEd ROSのrosed]を詳しくは参照してください。
===主に使う形===
===参考===



= ROS_PACKAGE_PATHについて =
{{{
//コマンドのcdと同じく、指定されたディレクトリに移るコマンド
roscd パッケージ名
//コマンドのlsと同じく、指定されたディレクトリ内を表示するコマンド
rosls パッケージ名
}}}
上のrosのコマンドなどと同じように、
用意されているrosのそのほかのコマンドもさまざまなディレクトリに入っているパッケージ名を引数にすることがほとんどです。

これらのパッケージが、さまざまなディレクトリにあるにもかかわらず、rosのコマンドがそれぞれのパッケージのあるディレクトリを知っているのは、もちろんパスを環境変数として通してあるからです。
{{{
env | grep ROS
}}}
と打ってみてください。ご存知とは思いますが、envは環境変数を表示し、その中でROSの文字列を含むものをgrepで絞り込んで表示させています。

その中に、
{{{
ROS_PACKAGE_PATH
}}}
があると思います。これに、それらのパッケージがあるとされるディレクトリのパスを書いていきます。
{{{
user@ubuntu:~/ros/fuerte/jsk-ros-pkg$ ls
・・・
elevator_move_base_pr2   jsk.rosbuild         pr2eus_tutorials
euscollada               jsk.rosbuild~        pr2pose
euslisp                  jsk.rosinstall       roseus
jsk_common               jsk_semantic_maps    roseus_tutorials//←パッケージ名
・・・
}}}
たとえば、おそらくよく使うパッケージのひとつとして、roseus_tutorialsがあるとおもいますが、これをroscdなどでパッケージとして認識してもらって使えるようにするには、これの親のディレクトリであるjsk-ros-pkgをROS_PACKAGE_PATHに登録しなくてはなりません。おそらく、さきほどのROS_PACKAGE_PATHにjsk-ros-pkgの文字も見られると思います。このroseus_tutorialsはすでに登録されているので、
{{{
roscd roseus_tu
}}}
ぐらいまで打って、TABキーを押せば自動に補完されて、実行をすると
{{{
~/ros/fuerte/jsk-ros-pkg/roseus_tutorials
}}}
などのように用意に目的のディレクトリに移動することができます。