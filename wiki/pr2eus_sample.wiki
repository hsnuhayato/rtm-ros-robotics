#summary PR2_euslispのサンプルプログラム

<wiki:toc max_depth="2" />

= pr2eusの動かし方 =
~/.bashrcに以下の2行を追加

{{{
source ~/ros/fuerte/setup.bash
export PATH=$PATH:$(rospack find roseus)/bin
}}}

== pr2eus(eus単体で使う) ==
source ~/.bashrcをする

{{{
１つのターミナルで roscore を立ち上げる
別のターミナルで rosrun pr2eus pr2-send-joints.l がエラー無く動いたら成功
（ ２つの ウインドウが出てきて pr２が動く）
}}}

== gazeboを使う ==

{{{
roslaunch pr2eus_tutorials pr2_gazebo_empty.launch ( pr2 のシミュレーション環境が立ち上がる）
rosrun pr2eus pr2-send-joints.l  が動くか
（ ウィンドウが１つでて、シミュレーション環境とrviz内の PR2が動くか？）
}}}

== pr2 を動かす準備 ==
=== 初期設定 ===
{{{
.bashrcに以下を追加

function rossetrobot() { # 自分のよく使うロボットのhostnameを入れる
    local hostname=${1-"pr1012"}
    local ros_port=${2-"11311"}
    export ROS_MASTER_URI=http://$hostname:$ros_port
    echo -e "\e[1;31mset ROS_MASTER_URI to $ROS_MASTER_URI\e[m"
}
function rossetlocal() {
    export ROS_MASTER_URI=http://localhost:11311
    echo -e "\e[1;31mset ROS_MASTER_URI to $ROS_MASTER_URI\e[m"
}
function rossetip() {
  export ROS_IP=`LANGUAGE=en LANG=C ifconfig | grep inet\  | grep -v 127.0.0.1 | sed 's/.*inet addr:\([0-9\.]*\).*/\1/' | head -1`
  export ROS_HOSTNAME=$ROS_IP
  echo -e "\e[1;31mset ROS_IP and ROS_HOSTNAME to $ROS_IP\e[m"
}
function rossetpr2() {
    rossetip
    rossetrobot pr1012
}
}}}

=== ロボットを動かす ===
{{{
rossetpr2
  # メッセージが出る set ROS_IP and ROS_HOSTNAME to xxx.xxx.xxx.xxx
  # xxx.xxx.xxx.xxxがPR2のアドレスと同じネットワークにあるか確認する
}}}

{{{
rosrun roseus roseus (rossetpr2したのと同じターミナルで実行)

(load "package://pr2eus/pr2-interface.l")

(setq *ri* (instance pr2-interface :init))
(pr2)
(objects (list *pr2*))

(send *ri* :angle-vector (send *pr2* :angle-vector)) ## ロボットがviewerのpr2と同じ姿勢になる
(send *pr2* :angle-vector (send *ri* :state :potentio-vector)) ## viewerのpr2を実機と同じ姿勢にする

;;; 以降 euslispのコマンドを参照してPR2を動かす
}}}

= euslispのコマンド =

== 変数 ==
{{{
*pr2* <- (pr2) ## PR2のeuslispモデルを作る
*ri* <- (instance pr2-interface :init) ## PR2とeuslispとロボットのインターフェースを作る
*irtviewer* <- (make-irtviwer) ## viewerを作る
}}}

== メソッド == 
;; *pr2*
{{{
(send *pr2* :reset-pose)   # reset-pose(初期姿勢）になる
(send *pr2* :angle-vector) # anglve-vector(関節角度列）を返す

(send *pr2* limb joint :joint-angle [ angle ]) # 1つの関節を動かす angleの単位系は degree または mm
;; limb joint
:torso :waist-z
:larm
:rarm :collar-y
      :shoulder-p
      :shoulder-y
      :elbow-p
      :elbow-r
      :wrist-p
      :wrist-r
      :gripper
:head :neck-p
      :neck-y

(send *pr2* :torso :waist-z :joint-angle 100) # :torso(胴体) :waist-z（腰z軸方向）に 100mm 動く

(send *pr2* :rarm :move-end-pos (float-vector 0  170 400) :world :rotation-axis nil)
# 手先を移動させる :world は世界座標系（:localをと手先座標系） :rotation-axis 

(send *pr2* :head :look-at
      (apply 'midpoint 0.5 (send *pr2* :arms :end-coords :worldpos)))
# :head :look-at [ point or coordinate ] 指定された点に顔を向ける

(send *pr2* :larm :end-coords) # 手先座標系を返す
(send *pr2* :larm :inverse-kinematics coords [ :rotation-axis xx ] [ :use-torso t ]
# 逆運動学 手先座標系を coords に合わせる :rotation-axis xx (xxはt,nil,:xなど、tにすると位置だけ合わせて回転は無視する） :use-torso t で腰関節を使う
}}}

;; *ri*
{{{
(send *ri* :angle-vector (send *pr2* :angle-vector) 3000) # ロボットに姿勢を送る（ロボットが動く） 3000 はかかる時間、単位はms(ミリ秒)

(send *ri* :wait-interpolation) # ロボットが動き終わるのを待つ send *ri* :angle-vectorはすぐに返ってくる
(send *ri* :start-grasp :rarm) # グリッパーを握る
(send *ri* :stop-grasp :rarm) # グリッパーを開く

(send *ri* :go-pos 0 -0.04 0) # 移動（障害物回避する） X方向 Y方向 回転 を指示する、方向の単位はm、回転はdegree
(send *ri* :go-pos-unsafe -0.1 0 0) # 移動（障害物回避しない）、指示はgo-posと同じ
(send *ri* :state :potentio-vector) # 実機の現在の姿勢を返す
(send *ri* :angle-vector-sequence (list av0 av1 av2) (list tm0 tm1 tm2))
# 関節角度列を送る（たくさんの姿勢を連続的に送る）

(send *ri* :state :worldcoords) # ロボットの現在位置を返す
(send *ri* :move-to coords) # ロボットをcoordsへ移動させる
}}}

;; *irtviewer*
{{{
(send *irtviewer* :draw-objects) # viewerの更新
(objects (list *pr2* (make-cube))) # viewerに表示するobjectを指定する
}}}