#include <iostream>
#include <cv.h>
#include <ml.h>
#include <highgui.h>
#include <boost/numeric/ublas/vector.hpp>
#include <boost/numeric/ublas/io.hpp>
// #include "colorlib-rgb.h"
// #include "colorlib-lab.h"

using namespace cv;

typedef boost::numeric::ublas::vector<double> dvector;

static const int GaussN = 3;
static int coldim = 3;

vector<dvector> readData(string trainfile)
{
	vector<dvector> data;
	FILE *fp;
	if((fp = fopen(trainfile.c_str(), "r")) == NULL)
		{
			cerr << "no such file: " << trainfile << endl;
			exit(1);
		}
	float x,y,z;
	while(fscanf(fp,"%f %f %f\n",&x,&y,&z) != EOF)
		{
			dvector color(3);
			color(0) = x;
			color(1) = y;
			color(2) = z;
			data.push_back(color);
		}

	return data;
}

void train(string trainfile,CvEM& source_model)
{
	vector<dvector> data = readData(trainfile);

  Mat src(data.size(),3,CV_32FC1);
	vector<dvector>::iterator it = data.begin();
  for(int i=0; it != data.end(); it++,i++)
		for(int j=0; j<3; j++)
			src.at<float>(i,j) = (*it)(j);

  CvEMParams params(GaussN); //GaussN: number of gaussians

  // phase 1 (initial estimation)
  CvEM tmp_model;
  params.covs = NULL;
  params.means = NULL;
  params.weights = NULL;
  params.probs = NULL;
  params.cov_mat_type       = CvEM::COV_MAT_SPHERICAL;
  params.start_step         = CvEM::START_AUTO_STEP;
  params.term_crit.max_iter = 100;
  params.term_crit.epsilon  = 0.1;
  params.term_crit.type     = CV_TERMCRIT_ITER|CV_TERMCRIT_EPS;

  tmp_model.train(src, Mat(), params, NULL);

  // phase 2 (main estimation)
  params.cov_mat_type  = CvEM::COV_MAT_GENERIC; //COV_MAT_DIAGONAL, COV_MAT_SPHERICAL
  params.start_step    = CvEM::START_E_STEP;
  params.means = tmp_model.get_means();
  params.covs = (const CvMat**)tmp_model.get_covs();
  params.weights = tmp_model.get_weights();

  source_model.train(src, Mat(), params, NULL);
}

void outputLearnResult(string colormode,string varname,vector<Mat>& means,vector<Mat>& icovs)
{
	char filename[128];
	sprintf(filename,"%s_%s.h",colormode.c_str(),varname.c_str());
	
	FILE *fp = fopen(filename,"w");
	fprintf(fp,"/* this file is automatically generated. Do not edit */\n\n");

	fprintf(fp,"float %s_%s_ave[%d][3] = {\n",colormode.c_str(),varname.c_str(),means.size());
	vector<Mat>::iterator it = means.begin();
	for(; it != means.end(); it++)
		fprintf(fp,"  {%f, %f, %f},\n", 
						(*it).at<float>(0,0),(*it).at<float>(0,1),(*it).at<float>(0,2));
	fprintf(fp,"};\n\n");

	fprintf(fp,"float %s_%s_var[%d][3][3] = {\n",colormode.c_str(),varname.c_str(),means.size());
	it = icovs.begin();
	for(; it != icovs.end(); it++)
		{
			fprintf(fp,"  {");
			for(int i=0; i<3; i++)
				fprintf(fp,"{%f, %f, %f},",
								(*it).at<float>(i,0),(*it).at<float>(i,1),(*it).at<float>(i,2));
			fprintf(fp,"},\n");
		}
	fprintf(fp,"};\n");

	fclose(fp);
}

void proc(CvEM& source_model,string colormode,string varname)
{
  vector<Mat> means,icovs;
  CvEMParams p(GaussN); //GaussN: number of gaussians
  p.means = source_model.get_means();
  p.covs = (const CvMat**)source_model.get_covs();
  float means_v[GaussN][coldim], icovs_m[GaussN][coldim][coldim];
  for(int i=0; i<GaussN; i++)
    {
      CvMat *mat = cvCreateMat(coldim,coldim,CV_64F);
      cvInvert(p.covs[i],mat);
      for(int j=0; j<coldim; j++)
				{
					means_v[i][j] = cvmGet(p.means,i,j);
					for(int k=0; k<coldim; k++)
						icovs_m[i][j][k] = cvmGet(mat,j,k);
				}
      cvReleaseMat(&mat);

      means.push_back(Mat(1,coldim,CV_32F,means_v[i]));
      icovs.push_back(Mat(coldim,coldim,CV_32F,icovs_m[i]));
    }
	outputLearnResult(varname,colormode,means,icovs);
}


int main(int argc,char *argv[])
{
	if(argc < 3)
		{
			cerr << "usage: ./color trainfile colormode varname" << endl;
			exit(1);
		}

  CvEM source_model;
	train(string(argv[1]),source_model);
	proc(source_model,string(argv[2]),string(argv[3]));

	return 1;
}
