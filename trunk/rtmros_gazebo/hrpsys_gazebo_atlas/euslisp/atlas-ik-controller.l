#!/usr/bin/env roseus

(ros::load-ros-manifest "roseus")
(ros::load-ros-manifest "move_base_msgs")

(ros::load-ros-manifest "hrpsys_gazebo_atlas")
(ros::load-ros-manifest "arm_navigation_msgs")
(ros::load-ros-manifest "moveit_msgs")
(ros::load-ros-manifest "jsk_interactive")
(ros::load-ros-manifest "jsk_interactive_marker")

(ros::roseus "atlas-ik-controller")

(require "atlas-model.l")
(require "atlas-fullbody-ik.l")
(require "package://hrpsys_gazebo_atlas/euslisp/atlas-joint-state-compresser-settings.l")
(require "models/arrow-object.l")
(require "package://roseus/euslisp/actionlib.l")

;;;;;;;; setup ;;;;;;;;;;;

(defun call-ik-server
  (&key
   (target-limb
    (case *move-limb*
	  (:arms :larm)
	  (t *move-limb*)))
   (group_name
    (nth
     (cond
      (*use-torso* 1)
      (*use-fullbody* 2)
      (t 0))
     (case target-limb
	   (:larm '("larm_eus" "larm_torso_eus" "larm_fullbody_eus"))
	   (:rarm '("rarm_eus" "rarm_torso_eus" "rarm_fullbody_eus")))))
   (req (instance moveit_msgs::GetPositionIKRequest :init))
   (move-coords (make-coords))
   (initial-coords
    (send *robot* target-limb :end-coords :copy-worldcoords))
   (target-coords
    (make-coords
     :pos (v+ (send initial-coords :worldpos)
    	      (send move-coords :worldpos))
     :rot (m* (send move-coords :worldrot)
    	      (send initial-coords :worldrot)
    	      )))
   (target-coords-from-pelvis
    (send (send *robot* :copy-worldcoords)
	  :transformation target-coords))
   (prev-state
    (list (cons :angle-vector
		(copy-seq (send *robot* :angle-vector)))
	  (cons :worldcoords
		(copy-object (send *robot* :worldcoords)))))
   (log-stream t)
   (translation-axis *translation-axis*)
   (rotation-axis *rotation-axis*)
   (update-convex t)
   &allow-other-keys
   )
  (cond
   (*ik-stop*
    (return-from call-ik-server nil)))
  (let* ((c target-coords-from-pelvis)
	 (p (scale 1e-3 (send c :worldpos)))
	 (q (matrix2quaternion (send c :worldrot)))
	 res)
    (send req :ik_request :group_name group_name)
    ;;
    (send *prev-js*
	  :header
	  (instance std_msgs::Header :init
		    :stamp (ros::time 0.0)
		    :frame_id "/pelvis"))
    (send *prev-js*
	  :position
	  (map float-vector
	       #'deg2rad
	       (send *robot* :angle-vector)))
    (send req :ik_request :robot_state :joint_state *prev-js*)
    ;;
    (send req :ik_request :constraints :name
	  (apply
	   #'concatenate
	   (append
	    (list string)
	    (list "(")
	    (mapcar
	     #'(lambda (key val) (format nil "~A ~A " key val))
	     '(:translation-axis :rotation-axis :stop :update-convex
	       :thre :rthre)
	     (list
	      (list translation-axis t t)
	      (list rotation-axis t t)
	      10
	      update-convex
	      (list (max 1 (* 0.9 (norm (send move-coords :worldpos))))
		    5 5)
	      (list (max (deg2rad 5)
			 (* 0.9 (norm
				 (coerce
				  (car (send move-coords :rpy-angle))
				  float-vector))))
		    (deg2rad 5) (deg2rad 5))
	      ))
	    (list ")"))))
    ;;
    (send req :ik_request
	  :pose_stamped
	  (instance geometry_msgs::PoseStamped :init
		    :header
		    (instance std_msgs::Header :init
			      :stamp (ros::time 0.0)
			      :frame_id "/pelvis")
		    :pose
		    (instance geometry_msgs::Pose :init
			      :position
			      (instance geometry_msgs::Point
					:init
					:x (elt p 0)
					:y (elt p 1)
					:z (elt p 2))
			      :orientation
			      (instance geometry_msgs::Quaternion
					:init
					:x (elt q 1)
					:y (elt q 2)
					:z (elt q 3)
					:w (elt q 0)))
		    ))
    (setq res (ros::service-call "/atlas_eus_ik" req))
    (cond
     ((= (send res :error_code :val)
	 moveit_msgs::MoveItErrorCodes::*SUCCESS*)
      (format log-stream "successed!~%")
      (setq *prev-js* (send res :solution :joint_state))
      (send *robot* :angle-vector
	    (map float-vector
		 #'rad2deg
		 (send res :solution :joint_state :position)))
      (send *robot* :fix-leg-to-coords
	    (make-coords) :both)
      (send *viewer* :draw-objects)
      ;;
      (if (or
	   (null *success-state-collection*)
	   (> (norm
	       (v- (send *robot* :angle-vector)
		   (cdr (assoc :angle-vector prev-state))))
	      1))
	  (setq *success-state-collection*
		(subseq
		 (cons
		  (list (cons :angle-vector
			      (copy-object
			       (send *robot* :angle-vector)))
			(cons :worldcoords
			      (copy-object
			       (send *robot* :worldcoords))))
		  *success-state-collection*)
		 0 500)))
      (send *robot* :angle-vector)
      )
     (t (format log-stream "failed!~%") nil))))

(defvar *touch-it-interface*
  (setq *c* (instance ros::simple-action-client :init
		      "/touchit/act/exec"
		      move_base_msgs::MoveBaseAction)))
(defvar *touch-it-interface-ocs*
  (setq *c* (instance ros::simple-action-client :init
		      "/touchit/act/exec_ocs"
		      move_base_msgs::MoveBaseAction)))
(defvar *touchit-reached* 9)
(defvar *touchit-touched* 3)

(defvar *touchit-target-larm* 0)
(defvar *touchit-target-larm-torso* 1)
(defvar *touchit-target-larm-fullbody* 2)
(defvar *touchit-target-rarm* 3)
(defvar *touchit-target-rarm-torso* 4)
(defvar *touchit-target-rarm-fullbody* 5)

(defun call-touch-it-server
  (command
   &key (ik-type
	 (cond
	  ((eq *move-limb* :rarm)
	   (cond
	    (*use-fullbody* *touchit-target-rarm-fullbody*)
	    (*use-torso* *touchit-target-rarm-torso*)
	    (t *touchit-target-rarm*)))
	  ((eq *move-limb* :larm)
	   (cond
	    (*use-fullbody* *touchit-target-larm-fullbody*)
	    (*use-torso* *touchit-target-larm-torso*)
	    (t *touchit-target-larm*)))))
	(frame_id "/pelvis")
	(target-coords *target-coords*)
	(target-coords-from-pelvis
	 (send (send *robot* :copy-worldcoords)
	       :transformation target-coords))
	(touch-it-interface
	 (case command
	       (:prev *touch-it-interface-ocs*)
	       (t *touch-it-interface*)))
	(axis *rotation-axis*)
	res)
  (case command
	(:prev nil)
	(t (send touch-it-interface :cancel-all-goals)))
  (case command
	(:cancel (send touch-it-interface :cancel-all-goals))
	(t
	 (let* ((c target-coords-from-pelvis)
		(p (scale 1e-3 (send c :worldpos)))
		(q (matrix2quaternion (send c :worldrot)))
		goal)
	   ;; set request
	   (warning-message 2 "[touch_it_client] start waiting for server~%")
	   (send touch-it-interface :wait-for-server)
	   (warning-message 2 "[touch_it_client] finish waiting for server ~%")
	   (setq goal (instance move_base_msgs::MoveBaseActionGoal :init))
	   (send goal :goal :target_pose :header :frame_id frame_id)
	   (send goal :goal :target_pose :header :stamp (ros::time 0.0))
	   (send goal :goal :target_pose :pose :position :x (elt p 0))
	   (send goal :goal :target_pose :pose :position :y (elt p 1))
	   (send goal :goal :target_pose :pose :position :z (elt p 2))
	   (send goal :goal :target_pose :pose :orientation :x (elt q 1))
	   (send goal :goal :target_pose :pose :orientation :y (elt q 2))
	   (send goal :goal :target_pose :pose :orientation :z (elt q 3))
	   (send goal :goal :target_pose :pose :orientation :w (elt q 0))
	   (send goal :goal :target_pose :header :seq ik-type)
	   (send (send goal :goal_id) :id (format nil "~A" axis))
	   ;; send request
	   (warning-message 2 "[touch_it_client] send goal to server ~%")
	   (send touch-it-interface :send-goal goal)
	   ;; wait
	   (warning-message 2 "[touch_it_client] start waiting for result~%")
	   (send touch-it-interface :wait-for-result)
	   )))
  ;; (warning-message 2 "[touch_it_client] result1: ~a ~%" (send *c* :get-result))
  (setq res (send touch-it-interface :get-state))
  ;; (warning-message 2 "[touch_it_client] result2: ~a ~%" res)
  (publish-touchit-result
   (format nil
	   "~A (CODE: ~A)"
	   (cond
	    ((eq res *touchit-touched*) "TOUCHED")
	    ((eq res *touchit-reached*) "REACHED")
	    (t "UNKNOWN"))
	   res))
  res)

;; initial pose
(defun init-pose
  nil
  (send *robot* :reset-manip-pose)
  (send *robot* :fix-leg-to-coords (make-coords) :both)
  (if (and (boundp '*viewer*) *viewer*)
      (send *viewer* :draw-objects))
  )

;;;;;;;; setup ;;;;;;;;;;;

;;;;;;;; controller ;;;;;;;;;

(defun str-subscriber
  (msg)
  (let ((command (send msg :data))
	(move))
    (if (zerop (length command))
	(setq command "hoge"))
    (setq move
	  (scale
	   5
	   (case (aref command 0)
	     (#\u #F(0 0 1))
	     (#\d #F(0 0 -1))
	     (#\r #F(0 -1 0 ))
	     (#\l #F(0 1 0))
	     (#\f #F(1 0 0))
	     (#\b #F(-1 0 0))
	     (#\v (read-from-string
		   (concatenate
		    string
		    "#f"
		    (subseq command 1))))
	     (t #F(0 0 0)))))
    (call-ik-server
     :move-coords
     (make-coords :pos move))))

(defun spacenav-subscriber
  (msg
   &optional
   (move-filter '(1 1 1))
   (rpy-filter '(1 1 1)))
  (cond
   ((and (> (aref (send msg :buttons) 0) 0.1)
	 (> (aref (send msg :buttons) 1) 0.1))
    (format t "mouse-mode~%")
    (format t "standby..?~%")
    (setq *mouse-mode* (not *mouse-mode*))
    (print 3) (unix:sleep 1)
    (print 2) (unix:sleep 1)
    (print 1) (unix:sleep 1)
    (format t "start!!~%")
    )
   ((not *mouse-mode*)
    (return-from spacenav-subscriber nil))
   ((> (aref (send msg :buttons) 1) 0.1)
    (print 'waist-fix)
    (waist-fix :waist-key :waist-r :cnt 3)
    (waist-fix :waist-key :waist-p :cnt 3)
    (waist-fix :waist-key :waist-y :cnt 3)
    (print 'done)
    )
   ((null *success-state-collection*) nil)
   ((> (aref (send msg :buttons) 0) 0.1)
    (print 'pop-back-robot-state)
    (let ((state (pop *success-state-collection*)))
      (send *robot* :angle-vector
	    (cdr (assoc :angle-vector state)))
      (send *robot* :newcoords
	    (cdr (assoc :worldcoords state)))
      (send *viewer* :draw-objects))
    ))
  (let ((move
	 (scale
	  30
	  (coerce
	   (subseq (send msg :axes) 0 3)
	   float-vector)))
	(rpy
	 (reverse
	  (scale
	   0.12
	   (coerce
	    (subseq (send msg :axes) 3 6)
	    float-vector)))))
    (cond
     ((< (norm
	  (concatenate
	   float-vector
	   (scale 1e-3 move)
	   rpy)) 0.01)
      (format t "skip ~A ~A~%" move rpy))
     (t
      (setq move
	    (map float-vector
		 #'*
		 move move-filter))
      (setq rpy
	    (map float-vector
		 #'*
		 rpy rpy-filter))
      (if (and
	   (vectorp
	    (call-ik-server
	     :rotation-axis t
	     :translation-axis t
	     :move-coords
	     (make-coords :pos move :rpy rpy)))
	   *publish-ik*)
	  (publish-joint-states :real? nil))
      ))))

;; (defun joint-state-callback
;;   (msg)
;;   (let ((joint-names (send msg :name))
;; 	(joint-angles (send msg :position))
;; 	joint-name joint-angle
;; 	)
;;     (dotimes (x (length joint-names))
;;       (setq joint-name (elt joint-names x))
;;       (setq joint-angle (rad2deg (elt joint-angles x)))
;;       (send *robot* (intern (string-upcase joint-name) *keyword-package*)
;; 	    :joint-angle joint-angle)
;;       (when (boundp '*irtviewer*) (send *irtviewer* :draw-objects))   
;;       )
;;     )
;;   )

(defun joint-state-subscriber2
  (msg)
  (format t "[joint-state-subscriber] called ")
  (bench
   (let ((joint-names (send msg :name))
	 (joint-angles (send msg :position))
	 joint-name joint-angle
	 buf
	 )
     ;;(describe msg)
     (dotimes (x (length joint-names))
       (setq joint-name (elt joint-names x))
       ;;(print joint-name)
       (setq joint-angle (rad2deg (elt joint-angles x)))
       (setq buf
	     (intern (string-upcase joint-name) *keyword-package*))
       (if (find-method *robot* buf)
	   (send *robot* buf :joint-angle joint-angle))
       )
     (send *robot*
	   :fix-leg-to-coords (make-coords) :both)
     (when (boundp '*irtviewer*) (send *irtviewer* :draw-objects))
     )))


(defun joint-state-subscriber
  (msg)
  (format t "[joint-state-subscriber] called ")
  (bench
   (let ((joint-names (send msg :name))
	 (joint-angles (send msg :position))
	 joint-name joint-angle
	 buf
	 )
     ;;(describe msg)
     (dotimes (x (length joint-names))
       (setq joint-name (elt joint-names x))
       ;;(print joint-name)
       (setq joint-angle (rad2deg (elt joint-angles x)))
       (setq buf
	     (intern (string-upcase joint-name) *keyword-package*))
       (if (find-method *real-robot* buf)
	   (send *real-robot* buf :joint-angle joint-angle))
       )
     (send *real-robot*
	   :fix-leg-to-coords (make-coords) :both)
     (case *orgin-key*
	   (:free nil)
	   (t (send *origin-coords* :move-to
		    (send *real-robot* *orgin-key*
			  :end-coords :copy-worldcoords)
		    :world)))
     (when (boundp '*irtviewer*) (send *irtviewer* :draw-objects))
     )))

(defun ros::tf-point->tf-pose (point)
  (let ((pose (instance geometry_msgs::PoseStamped :init
                        :header (instance std_msgs::header :init
                                          :frame_id (send point :header :frame_id)
                                          :stamp (send point :header :stamp)))))
    (send pose :pose :position :x (send point :point :x))
    (send pose :pose :position :y (send point :point :y))
    (send pose :pose :position :z (send point :point :z))
    (send pose :pose :orientation :w 1.0)
    pose))

(defun waist-fix
  (&key
   (waist-key :waist-r)
   (waist-joint (send *robot* :torso waist-key))
   (waist-angle (send waist-joint :joint-angle))
   (angle-target 0)
   (prev-waist-angle waist-angle)
   (move-step 1)
   (target-coords
    (send *robot* *move-limb*
	  :end-coords :copy-worldcoords))
   (cnt 10)
   (ret #F()))
  (while (and (vectorp ret)
	      (> (abs (- waist-angle angle-target))
		 move-step)
	      (plusp (decf cnt)))
    (x::window-main-one)
    (setq prev-waist-angle waist-angle)
    (setq waist-angle
	  (* (if (> waist-angle 0) 1 -1)
	     (- (abs waist-angle) move-step)))
    (send waist-joint :joint-angle waist-angle)
    (setq ret (call-ik-server ;:target-coords target-coords
	       :rotate? :x)))
  (if (not (vectorp ret))
      (send waist-joint :joint-angle prev-waist-angle)))

(defun hand-even-fix
  (&key
   (rpy-id 2)
   (rpy-target 0)
   (cnt 10)
   (rpy-step (deg2rad 3))
   )
  (let* (now-rpy
	 now-target
	 ret)
    (do-until-key
     (x::window-main-one)
     (setq now-rpy
	   (car (send *gun-coords* :rpy-angle)))
     (setq now-target (nth rpy-id now-rpy))
     (if (< (abs (- now-target rpy-target)) rpy-step)
	 (return-from nil nil))
     (if (< (decf cnt) 0) (return-from nil nil))
     (setq index -1)
     (setq
      ret
      (call-ik-server
       :move-coords
       (make-coords
	:rpy
	(mapcar
	 #'(lambda (rpy)
	     (cond
	      ((not (eq (incf index) rpy-id)) 0)
	      ((< (- rpy-target now-target) 0)
	       (* -1 rpy-step))
	      (t rpy-step)))
	 now-rpy))))
     (if (not ret) (return-from nil nil)))))

(defun base-fix
  (&key
   (base-id 0)
   (base-rpy
    (car (send *robot* :rpy-angle)))
   (prev-base-rpy base-rpy)
   (move-step
    (let ((index -1))
      (mapcar
       #'(lambda (hoge)
	   (if (eq (incf index) base-id)
	       (deg2rad 1) 0))
       (make-list 3))))
   (cnt 10)
   (ret #F())
   buf)
  (while (and (vectorp ret)
	      (> (abs (nth base-id base-rpy))
		 (nth base-id move-step))
	      (plusp (decf cnt)))
    (setq prev-base-rpy base-rpy)
    (setq base-rpy
	  (mapcar
	   #'(lambda (rpy step)
	       (* (if (> rpy 0) 1 -1)
		  (- (abs rpy) step)))
	   base-rpy move-step))
    (send *robot* :newcoords
	  (make-coords
	   :pos (copy-object (send *robot* :worldpos))
	   :rpy (copy-object base-rpy)))
    (send *viewer* :draw-objects)
    (read-line)
    (setq ret (call-ik-server
	       :rotate? :x :debug-view nil)))
  (if (not (vectorp ret))
      (send *robot* :newcoords
	    (make-coords
	     :pos (copy-object (send *robot* :worldpos))
	     :rpy (copy-object prev-base-rpy)))))

;;Interactive Marker Callback
(defun marker-menu-callback
  ( msg )
  (let ((menu (send msg :menu))
	(type (send msg :type)))
    (cond
     ((eq menu jsk_interactive_marker::MarkerMenu::*SET_ORIGIN*)
      (setq *orgin-key* :free)
      (set-origin)
      ;;(publish-joint-states :real? nil)
      )
     ;;reset target coords
     ((eq menu jsk_interactive_marker::MarkerMenu::*RESET_COORDS*)
      (send *target-coords* :move-to *old-coords* :world)
      (set-marker-pose-robot (send *target-coords* :worldcoords))
      )
     ;;set origin to hand
     ((eq menu jsk_interactive_marker::MarkerMenu::*SET_ORIGIN_RHAND*)
      (format t "[marker-menu] set origin to rhand~%")
      (setq *orgin-key* :rarm)
      (set-origin-to-hand :rarm)
      ;;(publish-joint-states :real? nil)
      )
     ((eq menu jsk_interactive_marker::MarkerMenu::*SET_ORIGIN_LHAND*)
      (format t "[marker-menu] set origin to lhand~%")
      (setq *orgin-key* :larm)
      (set-origin-to-hand :larm)
      ;;(publish-joint-states :real? nil)
      )
     ;;change ik-rotation-axis
     ((eq menu jsk_interactive_marker::MarkerMenu::*IK_ROTATION_AXIS_T*)
      (format t "[marker-menu] set ik-rotation-axis t~%")
      (setq *rotation-axis* t)
      )
     ((eq menu jsk_interactive_marker::MarkerMenu::*IK_ROTATION_AXIS_NIL*)
      (format t "[marker-menu] set ik-rotation-axis nil~%")
      (setq *rotation-axis* nil)
      )
     ;;change use-torso
     ((eq menu jsk_interactive_marker::MarkerMenu::*USE_TORSO_T*)
      (setq *use-torso* t)
      (setq *use-fullbody* nil)
      )
     ((eq menu jsk_interactive_marker::MarkerMenu::*USE_TORSO_NIL*)
      (setq *use-torso* nil)
      (setq *use-fullbody* nil)
      )
     ((eq menu jsk_interactive_marker::MarkerMenu::*USE_FULLBODY*)
      (setq *use-torso* nil)
      (setq *use-fullbody* t)
      )
     ;;changeControllArm
     ((eq menu jsk_interactive_marker::MarkerMenu::*SET_MOVE_RARM*)
      (format t "[marker-menu] move rarm~%")
      (setq *move-limb* :rarm)
      )
     ((eq menu jsk_interactive_marker::MarkerMenu::*SET_MOVE_LARM*)
      (format t "[marker-menu] move larm~%")
      (setq *move-limb* :larm)
      )
     ((eq menu jsk_interactive_marker::MarkerMenu::*SET_MOVE_ARMS*)
      (format t "[marker-menu] move arms~%")
      (setq *move-limb* :arms)
      )
     ((eq menu jsk_interactive_marker::MarkerMenu::*PUBLISH_MARKER*)
      (publish-target-arrow-obj)
      (publish-origin-arrow-obj)
      )
     ((eq menu jsk_interactive_marker::MarkerMenu::*PLAN*)
      (format t "[marker-menu] publish joint states~%")
      (setq *ik-stop* nil)
      (setq *publish-ik* t)
      )
     ((eq menu jsk_interactive_marker::MarkerMenu::*CANCEL_PLAN*)
      (format t "[marker-menu] stop publishing joint states~%")
      (setq *ik-stop* t)
      (setq *publish-ik* nil)
      )
     ((eq menu jsk_interactive_marker::MarkerMenu::*TOUCHIT_EXEC*)
      (format t "[marker-menu] touch it exec~%")
      (call-touch-it-server :exec)
      )
     ((eq menu jsk_interactive_marker::MarkerMenu::*TOUCHIT_PREV*)
      (format t "[marker-menu] touch it prev~%")
      (call-touch-it-server :prev)
      )
     ((eq menu jsk_interactive_marker::MarkerMenu::*TOUCHIT_CANCEL*)
      (format t "[marker-menu] touch it cancel~%")
      (call-touch-it-server :cancel)
      )
     ((eq menu jsk_interactive_marker::MarkerMenu::*LOOK_RARM*)
      (format t "[marker-menu] look rarm~%")
      (look-hand :rarm)
      (publish-joint-states :real? nil)
      )
     ((eq menu jsk_interactive_marker::MarkerMenu::*LOOK_LARM*)
      (format t "[marker-menu] look larm~%")
      (look-hand :larm)
      (publish-joint-states :real? nil)
      )
     )
    (when (boundp '*irtviewer*)
      (send *irtviewer* :draw-objects))
    )
  (publish-arrow-tf)
  )

(defun marker-menu-callback2
  ( msg )
  (let ((menu (send msg :menu))
	(type (send msg :type)))
    (cond
     ((eq menu jsk_interactive_marker::MarkerMenu::*JOINT_MOVE*)
      (format t "[marker-menu] move robot!!~%")
      (publish-joint-states :real? t))
     ((eq menu jsk_interactive_marker::MarkerMenu::*RESET_JOINT*)
      (format t "[marker-menu] move robot!!~%")
      (realmodel2model)
      (publish-joint-states :real? nil))
     ((eq menu 100)
      (format t "[marker-menu] stand-pose~%")
      (send *robot* :stand-pose)
      (publish-joint-states :real? nil))
     ((eq menu 101)
      (format t "[marker-menu] reset-manip-pose~%")
      (send *robot* :reset-manip-pose)
      (publish-joint-states :real? nil))
     (t (format t "[marker-menu] unknonw(~A)~%" menu))
     )
    ))

;;called when marker is moved
(defun pose-callback
  (msg)
  (let* ((pose (send msg :pose))
	 (cds (ros::tf-pose-stamped->coords pose))
	 map->marker
	 )
    (while t
      (setq map->marker
	    (send *tfl* :lookup-transform
		  "pelvis" (send pose :header :frame_id) (ros::time 0)))
      (cond
       (map->marker
	(send cds :transform map->marker :world)
	(return)
	)
       (t
	(ros::ros-info "map -> marker cannnot transform yet")
	(ros::sleep)
	)
       )
      )
    (send *target-coords* :move-to
	  (send *robot* :worldcoords) :world)
    (send *target-coords* :transform cds)
    (when (boundp '*irtviewer*)
      (send *irtviewer* :draw-objects))
    )
  (publish-arrow-tf)
  )

(defun set-origin
  ()
  (realmodel2model)
  (setq *old-coords* (send *target-coords* :copy-worldcoords))
  (send *origin-coords* :move-to *target-coords* :world)
  )

(defun set-origin-to-hand
  (&optional (arm :rarm))
  (realmodel2model)
  (send *target-coords* :move-to
	(send *robot* arm :end-coords :worldcoords)
	:world)
  (set-origin)
  (set-marker-pose-robot (send *target-coords* :worldcoords))
  )

(defun realmodel2model
  ()
  (send *robot*
	:angle-vector
	(copy-object
	 (send *real-robot* :angle-vector)))
  (send *robot* :fix-leg-to-coords
	(make-coords) :both)
  (fix-centroid-object)
  )

;;fixed flamae is foot?
(defun get-base-coords
  ()
  (let (coords torso->map)
    (setq coords (send *robot* :copy-worldcoords))
    (while t
      (setq torso->map
	    (send *tfl* :lookup-transform
		  ;;"r_foot" "map" (ros::time 0)))
		  "pelvis" "map" (ros::time 0)))
      (cond
       (torso->map
	(send coords :transform torso->map)
	(return)
	)
       (t
	(ros::ros-info "pelvis -> map cannnot transform yet")
	(ros::sleep)
	)
       )
      )
    coords
    ;; (make-coords
    ;;  :pos
    ;;  (v+ (send coords :worldpos)
    ;; 	 (v- (send *robot* :worldpos)
    ;; 	     (send (send *robot* :r_foot_lk :worldcoords) :worldpos)))
    ;;  :rot
    ;;  (m*
    ;;   (transpose (send coords :worldrot))
    ;;   (m*
    ;;    (transpose
    ;; 	(send (send *robot* :r_foot_lk :worldcoords) :worldrot))
    ;;    (send *robot* :worldrot)))
    ;;  )
    )
  )

(defun set-marker-pose
  (coords &key (marker-name) (frame "/map") (markers) (server *server-nodename*))
  (let ((req (instance jsk_interactive_marker::MarkerSetPoseRequest :init))
	(msg (ros::coords->tf-pose-stamped coords frame)))
    (send req :marker_name marker-name)
    (send req :pose msg)
    (send req :markers markers)
    (ros::service-call (format nil "~A/set_pose" server)
		       req)
    ))

(defun set-marker-pose-robot
  (coords &rest args)
  (if args
      (apply #'set-marker-pose
	     (append
	      (list
	       (send (get-base-coords)
		     :transformation coords :local)
	       args)))
    (set-marker-pose
     (send (get-base-coords) :transformation coords :local))
    ))

(defun publish-arrow-tf
  ()
  (send *tfb* :send-transform
	(send (get-base-coords) :transformation
	      *target-coords* :local)
	"/map" "/im_target_coords_arrow")
  ;;
  (send *tfb* :send-transform
	(send (get-base-coords) :transformation
	      *origin-coords* :local)
	"/map" "/im_origin_coords_arrow")
  )

(defun publish-target-arrow-obj
  ()
  (let ((org  (send *target-coords* :copy-worldcoords)))
    (send *target-coords* :reset-coords)
    (send *target-coords* :worldcoords)
    (send-all (send *target-coords* :bodies) :worldcoords)
    (ros::publish (format nil "~A/marker" *server-nodename*)
		  (object->marker-msg *target-coords*
				      (instance std_msgs::header :init
						:frame_id "/im_target_coords_arrow")))
    (send *target-coords* :transform org)
    (send *target-coords* :worldcoords)
    )
  )

(defun publish-origin-arrow-obj
  ()
  (let ((org  (send *origin-coords* :copy-worldcoords)))
    (send *origin-coords* :reset-coords)
    (send *origin-coords* :worldcoords)
    (send-all (send *origin-coords* :bodies) :worldcoords)
    (ros::publish (format nil "~A/origin_marker" *server-nodename*)
		  (object->marker-msg *origin-coords*
				      (instance std_msgs::header :init
						:frame_id "/im_origin_coords_arrow")))
    (send *origin-coords* :transform org)
    (send *origin-coords* :worldcoords)
    )
  )

(defun publish-touchit-result
  (text)
  (let ((marker (instance visualization_msgs::marker :init)))
    (send marker :header :frame_id "/im_target_coords_arrow")
    (send marker :id 1)
    (send marker :lifetime (ros::time 5))
    (send marker :pose :position :z 1)
    (send marker :pose :orientation :w 1)
    (send marker :color :r 1)
    (send marker :color :g 1)
    ;;(send marker :color :b 1)
    (send marker :color :a 1)
    (send marker :scale :z 0.3)
    (send marker :type visualization_msgs::marker::*TEXT_VIEW_FACING*)
    (send marker :text text)
    (ros::publish (format nil "~A/marker" *server-nodename*) marker)
    )
  )

(defun publish-joint-states
  (&key
   (real? nil))
  (let ((joint-angles nil)
	(joint-names nil)
	(joint-list (send *robot* :joint-list))
	(joint-state-msg
	 (instance sensor_msgs::JointState :init
		   :header (instance std_msgs::header :init
				     :stamp (ros::time-now)))))
    (dotimes (x (length joint-list))
      (push (deg2rad (send (elt joint-list x) :joint-angle)) joint-angles)
      (push (send (elt joint-list x) :name) joint-names)
      )
    (send joint-state-msg :position joint-angles)
    (send joint-state-msg :name joint-names)
    ;;
    (cond
     (real?
      (ros::publish (format nil "~A/atlas/joint_states_ri_move" *im-nodename*)
		    joint-state-msg))
     (t
      (ros::publish (format nil "~A/atlas/reset_joint_states" *im-nodename*)
		    joint-state-msg)))
    )
  )

(defvar *target-coords* (instance arrow-object :init))
(send *target-coords* :translate #f(500 0 0)) ;; initial pose
(defvar *origin-coords* (instance arrow-object :init)) ;;arrow for origin of object
(send *origin-coords* :translate #f(500 0 0))
(defvar *old-coords* (send *target-coords* :copy-worldcoords))
(defvar *use-fullbody* nil)
(defvar *use-torso* nil)
(defvar *translation-axis* t)
(defvar *rotation-axis* t)
(defvar *publish-ik* nil)
(defvar *orgin-key* :rarm)
(defvar *ik-stop* (not *publish-ik*))

(defvar *im-nodename* "jsk_model_marker_interface")
(defvar *server-nodename*
  "/jsk_interactive_marker_manipulation")

;;initialize joint-index-list
;;it is used to convert joint-name -> index
(joint-index-init)

(ros::roseus "ik_server")
(setq *tfb* (instance ros::transform-broadcaster :init))
(setq *tfl* (instance ros::transform-listener :init))
(ros::load-ros-manifest "hrpsys_gazebo_atlas")
;;
(ros::roseus-add-msgs "hrpsys_gazebo_atlas")
(ros::roseus-add-msgs "sensor_msgs")
;;
(ros::subscribe "/ik_server_command"
		std_msgs::String
		#'str-subscriber
		1)
(ros::subscribe "/spacenav/joy"
		sensor_msgs::Joy
		#'spacenav-subscriber
		1)

(ros::advertise (format nil "~A/marker" *server-nodename*)
		visualization_msgs::Marker)
(ros::advertise
 (format nil "~A/origin_marker" *server-nodename*)
 visualization_msgs::Marker)
(ros::subscribe
 (format nil "~A/pose" *server-nodename*)
 jsk_interactive_marker::MarkerPose #'pose-callback 1)
(ros::subscribe
 (format nil "~A/marker_menu" *server-nodename*)
 jsk_interactive_marker::MarkerMenu #'marker-menu-callback 1)
(ros::subscribe
 (format nil "~A/marker_menu" *im-nodename*)
 jsk_interactive_marker::MarkerMenu #'marker-menu-callback2 1)
(ros::subscribe
 "/atlas/joint_states_decompressed"
 sensor_msgs::JointState
#'joint-state-subscriber 1)

;;Update Interactive Marker
(ros::advertise
 (format nil "~A/atlas/reset_joint_states" *im-nodename*)
 sensor_msgs::JointState)

(ros::subscribe
 (format nil "~A/atlas/joint_states" *im-nodename*)
 sensor_msgs::JointState #'joint-state-subscriber2)

(ros::advertise
 (format nil "~A/atlas/joint_states_ri_move" *im-nodename*)
 sensor_msgs::JointState)

(defun demo-mouse-controller
  nil
  (ros::rate 10)
  (do-until-key
   (if (not (ros::ok)) (return-from nil nil))
   (x::window-main-one)
   (ros::spin-once)
   (ros::sleep)))

(defun demo-pos-controller
  (&key
   (target-limb
    (case *move-limb*
	  (:arms '(:rarm :larm))
	  (t (list *move-limb*))))
   (now
    (mapcar
     #'(lambda (k)
	 (send *robot* k
	       :end-coords :copy-worldcoords))
     target-limb))
   (goal (copy-object now))
   (now-from-pelvis
    (mapcar
     #'(lambda (now goal)
	 (send (send *robot* :copy-worldcoords) :transformation now))
     now goal))
   (goal-from-pelvis
    (mapcar
     #'(lambda (now goal)
	 (send (send *robot* :copy-worldcoords) :transformation goal))
     now goal))
   (real? nil)
   (real-feedback? nil)
   (cnt 1000)
   (non-stop t)
   (return? nil)
   ;;
   (max-step 1000)
   (max-rstep (deg2rad 180))
   )
  (if return?
      (setq return?
	    (length *success-state-collection*)))
  (let (ret move rot buf tmp str)
    (do-until-key
     (bench
      (if (and (not non-stop)
	       (< (decf cnt) 0)) (return-from nil nil))
      (do-until-key
       (x::window-main-one)
       (ros::spin-once)
       (ros::sleep)
       (if (not *mouse-mode*) (return-from nil nil))
       )
      ;;
      ;;(waist-fix :waist-key :waist-r :cnt 3)
      ;;(waist-fix :waist-key :waist-p :cnt 3)
      ;;(waist-fix :waist-key :waist-y :cnt 3)
      ;;(hand-even-fix :cnt 1)
      ;;(dotimes (i 2)
      ;;(call-ik-server :rotate? :x :log-stream nil))
      (setq
       target-limb
       (case *move-limb*
	     (:arms '(:rarm :larm))
	     (t (list *move-limb*))))
      (setq
       now
       (mapcar
	#'(lambda (k)
	    (send *robot* k
		  :end-coords :copy-worldcoords))
	target-limb))
      (setq
       str
       (mapcar
	#'(lambda (k)
	    (send *real-robot* k
		  :end-coords :copy-worldcoords))
	target-limb))
      (setq
       goal
       (mapcar
	#'(lambda (str)
	    (send *origin-coords* :transformation str))
	str))
      (send-all goal :transform *target-coords* :world)
      (setq
       now-from-pelvis
       (mapcar
	#'(lambda (now goal)
	    (send (send *robot* :copy-worldcoords) :transformation now))
	now goal))
      (setq
       goal-from-pelvis
       (mapcar
	#'(lambda (now goal)
	    (send (send *robot* :copy-worldcoords) :transformation goal))
	now goal))
      (setq
       move
       (mapcar
	#'(lambda (now-from-pelvis goal-from-pelvis)
	    (transform
	     (send now-from-pelvis :worldrot)
	     (send now-from-pelvis :difference-position
		   goal-from-pelvis)))
	now-from-pelvis goal-from-pelvis))
      (setq
       rot
       (mapcar
	#'(lambda (now-from-pelvis goal-from-pelvis)
	    (transform
	     (send now-from-pelvis :worldrot)
	     (send now-from-pelvis :difference-rotation
		   goal-from-pelvis)))
	now-from-pelvis goal-from-pelvis))
      (format t
	      "[pos-controller] :dif-pos ~A, :dif-rot ~A, :sleep ~A "
	      (mapcar #'norm move) (mapcar #'norm rot) *ik-stop*)
      (if (and (not non-stop)
	       (< (apply #'max (mapcar #'norm move)) 10)
	       (< (apply #'max (mapcar #'norm rot)) (deg2rad 5)))
	  (return-from nil t))
      (setq move
	    (mapcar
	     #'(lambda (move)
		 (scale
		  (min 30 (norm move))
		  (normalize-vector move)))
	     move))
      (setq rot
	    (mapcar
	     #'(lambda (rot)
		 (scale (min (deg2rad 5) (norm rot))
			(normalize-vector rot)))
	     rot))
      (mapcar
       #'(lambda (limb move rot)
	   (setq tmp (call-ik-server
		      :target-limb limb
		      :real? real?
		      :move-coords
		      (make-coords
		       :pos move
		       :rpy (reverse rot))
		      :rotate? :x
		      :log-stream nil
		      )))
       target-limb move rot)
      (cond
       ((vectorp tmp))
       (nil ;(evenp (random 2))
	(setq tmp (call-ik-server
		   :real? real?
		   :real-feedback? real-feedback?
					;:rotate? :x
		   :move-coords
		   (make-coords
		    :pos (random-vector 30.0)
		    :rpy (random-vector (deg2rad 10)))
		   :log-stream nil
		   ))))
      (x::window-main-one)
      (if *publish-ik*
	  (publish-joint-states :real? nil))
      )))
  (if return?
      (subseq *success-state-collection*
	      0
	      (- (length *success-state-collection*)
		 return?))
    t)
  )

;; export ROS_MASTER_URI=http://10.10.72.112:11311
;; export ROS_IP=10.10.72.109 && export ROS_HOSTNAME=$ROS_IP
;; load "ssc-20131118.l"
;; load "ssc-20131119.l"
;; load "ssc-20131119-3.l"
(defun demo-collection-play
  (&key
   (real? nil)
   (data (reverse *success-state-collection*))
   (inital-sleep (if real? 10000 100))
   (cnt -1)
   d)
  ;; (cond
  ;;  (real?
  ;;   (init-grasp-pose)
  ;;   (model2real :sleep-time inital-sleep :wait t)))
  ;;
  (do-until-key
   (print (incf cnt))
   (if (null data) (return-from nil t))
   (setq d (car data))
   (setq data (cdr data))
   (send *robot* :angle-vector (cdr (assoc :angle-vector d)))
   (send *robot* :newcoords (cdr (assoc :worldcoords d)))
   (send *viewer* :draw-objects)
   (x::window-main-one)
   (cond
    (real?
     (model2real :sleep-time inital-sleep :wait t))
    (t (unix:usleep (round (* inital-sleep 1e+3)))))
   (setq inital-sleep 100))
  )

(atlas-with-hand)
(setq *robot* *atlas*)
(setq *real-robot* (copy-object *robot*))
(gl::transparent *real-robot* 0.3)
(setq *arrow* (arrow))
(make-centroid-object)
(init-pose)
(set-origin-to-hand *orgin-key*)

(objects
 (list *robot* *real-robot* *origin-coords* *target-coords*))
;;
(send *irtviewer* :change-background #f(0.9 0.9 1.0))
(send *irtviewer* :title "Interactive IK")

(send-all (send *robot* :joint-list) :max-joint-velocity 0.3)

(defvar *mouse-mode* nil)
(defvar *success-state-collection* nil)
(defvar *move-limb* :rarm)

(defvar *prev-js*
  (instance sensor_msgs::jointstate
	    :init
	    :header
	    (instance std_msgs::Header :init
		      :stamp (ros::time 0.0)
		      :frame_id "/pelvis")
	    :position
	    (map float-vector
		 #'deg2rad
		 (send *robot* :angle-vector))
	    :name
	    (send-all (send *robot* :joint-list) :name)))

(send *robot* :rleg :knee-p :min-angle 10)
(send *robot* :lleg :knee-p :min-angle 10)

;(demo-mouse-controller)
(send *robot* :angle-vector
      (copy-object (send *real-robot* :angle-vector)))
(send *real-robot*
      :fix-leg-to-coords (make-coords) :both)
(send *irtviewer* :draw-objects)
(send *irtviewer* :look-all)

(ros::rate 100)
(set-marker-pose-robot (send *target-coords* :worldcoords))
(demo-pos-controller)

#|

(ros::subscribe
 (format nil "~A/pose" server-nodename)
 jsk_interactive_marker::MarkerPose #'send self :pose-callback)

(ros::subscribe
 (format nil "~A/marker_menu" server-nodename)
 jsk_interactive_marker::MarkerMenu #'send self :move-callback)
