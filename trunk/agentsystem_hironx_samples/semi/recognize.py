
# -*- coding: utf-8 -*-

import roslib; roslib.load_manifest('iv_plan')

from numpy import *
from hironx_if import *
from openravepy import *

import cubeassembly

from init import *

def recognize(camera='lhand'):
    #マーカとブロックの座標の対応配列 [ブロック番号,[原点のずれ],[回転のずれ 軸,角度]]
    Tp_m_list=[
        [0,[-0.015,-0.015,0.06],[[1,0,0],[0,1,0],[0,0,1] ],26],
        [0,[0.03,-0.015,0.015],[ [0,0,1],[1,0,0],[0,1,0] ],28],
        [0,[-0.03,-0.015,0.015],[ [0,0,-1],[0,-1,0],[-1,0,0] ],29],
        [0,[-0.015,-0.015,0.00],[ [-1,0,0],[0,1,0],[0,0,-1] ],27],

        [1,[-0.015,0.015,0.03],[ [1,0,0],[0,-1,0],[0,0,-1] ],1],
        [1,[0,0.015,0.045],[ [0,0,1],[0,-1,0],[1,0,0] ],2],
        [1,[-0.015,0.015,0.06],[ [-1,0,0],[0,-1,0],[0,0,1] ],3],
        [1,[-0.015,0.06,0.045],[ [-1,0,0],[0,0,1],[0,1,0] ],4],
        [1,[-0.03,0.015,0.045],[ [0,0,-1],[-1,0,0],[0,1,0] ],5],
        [1,[-0.015,0.06,0.045],[ [1,0,0],[0,0,-1],[0,1,0] ],6],

        [2,[0.015,0.015,0.06],[ [1,0,0],[0,1,0],[0,0,1] ],34],
        [2,[0.03,0.015,0.045],[ [0,0,1],[0,-1,0],[1,0,0] ],32],
        [2,[0.015,0.045,0.0],[ [-1,0,0],[0,1,0],[0,0,-1] ],33],
        [2,[0.015,0.03,0.045],[ [-1,0,0],[0,0,-1],[0,-1,0] ],31],
        [2,[0.00,0.015,0.015],[ [0,0,-1],[0,-1,0],[-1,0,0] ],35],
        [2,[0.015,0.06,0.015],[ [-1,0,0],[0,0,1],[0,1,0] ],76],

        [3,[0.045,0.045,0.06],[ [0,1,0],[-1,0,0],[0,0,1] ],10],
        [3,[0.045,0.00,0.015],[ [0,-1,0],[0,0,-1],[1,0,0] ],9],
        [3,[0.045,0.045,0.00],[ [-1,0,0],[0,1,0],[0,0,-1] ],12],
        [3,[0.06,0.045,0.045],[ [0,0,1],[0,-1,0],[1,0,0] ],13],
        [3,[0.045,0.06,0.015],[ [-1,0,0],[0,0,1],[0,1,0] ],14],
        [3,[0.00,0.045,0.045],[ [0,0,-1],[1,0,0],[0,-1,0] ],15],


        [4,[0.045,-0.015,0.09],[ [-1,0,0],[0,-1,0],[0,0,1] ],8],
        [4,[0.045,-0.03,0.045],[ [1,0,0],[0,0,-1],[0,1,0] ],71],
        [4,[0.045,0.03,0.045],[ [1,0,0],[0,0,1],[0,-1,0] ],72],
        [4,[0.06,0.015,0.045],[ [0,0,1],[0,1,0],[-1,0,0] ],73],
        [4,[0.045,0.015,0.00],[ [-1,0,0],[0,1,0],[0,0,-1] ],74],
        [4,[0.03,0.015,0.045],[ [0,0,-1],[0,1,0],[1,0,0] ],75],

        [5,[0.015,0.015,0.09],[ [0,-1,0],[1,0,0],[0,0,1] ],24],
        [5,[0.015,0.045,0.06],[ [0,-1,0],[-1,0,0],[0,0,-1] ],21],
        [5,[0,0.045,0.075],[ [0,0,-1],[0,1,0],[1,0,0] ],25],
        [5,[0.045,0,0.075],[ [0,1,0],[0,0,-1],[-1,0,0] ],23],
        [5,[0.06,0.045,0.075],[ [0,0,1],[0,1,0],[-1,0,0] ],22], 
        [5,[0.045,0.06,0.075],[ [1,0,0],[0,0,1],[0,-1,0] ],77], 

        [6,[-0.015,-0.015,0.09],[ [1,0,0],[0,1,0],[0,0,1] ],17], 
        [6,[-0.015,0.06,0.075],[ [0,-1,0],[0,0,1],[-1,0,0] ],11],
        [6,[0.03,-0.015,0.075],[ [0,0,1],[0,-1,0],[1,0,0] ],20],
        [6,[-0.015,-0.03,0.075],[ [0,-1,0],[0,0,-1],[1,0,0] ],19],
        [6,[-0.03,-0.015,0.075],[ [0,0,-1],[0,1,0],[1,0,0] ],16],
        [6,[-0.015,-0.015,0.06],[ [-1,0,0],[0,1,0],[0,0,-1] ],18]
        ]
    
    #Tp_m_listの各行のマーカに格納されているidの配列
    id_index=[]
    for i in range(0,len(Tp_m_list)):
        id_index.append(Tp_m_list[i][3]-1)

    poselist=rr.recognize(camera)

    Tw_p_list=[]#Tw_pのリスト
    block_index_list=[]
    k=0

    for i in range(0,len(poselist)):#i:何番目に認識したブロックか
        f=ctsvc.ref.Query(camera+'cam', pose2mat(poselist[i][1]), robotframe, rr.get_joint_angles())
        f = reshape(f, (4,4))

        if poselist[i][0] not in id_index:
            continue

        blocknum=Tp_m_list[ id_index.index(poselist[i][0]) ][0]

        # vpython env => openrave env
        relvec = array([150,0,0]) + array([-450,0,-710])
        f[0:3,3] += relvec
        f[0:3,3] /= 1000

        # marker => piece
        Tp_m = eye(4)
        Tp_m[0:3,0:3] = Tp_m_list[ id_index.index(poselist[i][0]) ][2]
        Tp_m[0:3,3] = Tp_m_list[ id_index.index(poselist[i][0]) ][1]

        # f * Tp_m^-1
        Tw_p = dot(f,inverse_matrix(Tp_m))

        # Tw_p_list.append([blocknum,Tw_p])

        if blocknum not in block_index_list:# ブロックのリストに入っていなければ追加
            block_index_list.append(blocknum)
            Tw_p_list.append( [blocknum,Tw_p])
            self.gmodels[Tw_p_list[k][0]].target.SetTransform(Tw_p_list[k][1])
            k=k+1
        else:#ブロックのリストに入って座標のz軸とW系のz軸の内積が大きければ、ブロックの座標を入れ替え
            z=f[2][2]#既に登録されているブロックの座標のz軸のz成分
            index=block_index_list.index(blocknum)
            for i in range(0,len(block_index_list)):
                if Tw_p_list[ index ][1][2][2] > z:
                    Tw_p_list[ index ]=[blocknum,Tw_p] 
                    self.gmodels[Tw_p_list[index][0]].target.SetTransform(Tw_p_list[index][1])

    return Tw_p_list

